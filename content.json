{"meta":{"title":"山外小楼","subtitle":"前端攻略","description":"我是萌新","author":"萌新","url":"http://iyue.top","root":"/"},"pages":[{"title":"关于","date":"2018-08-12T06:34:55.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"about/index.html","permalink":"http://iyue.top/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-07-16T07:25:27.000Z","updated":"2022-01-09T08:17:42.025Z","comments":false,"path":"categories/index.html","permalink":"http://iyue.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-07-16T07:24:04.000Z","updated":"2022-01-09T08:17:42.025Z","comments":false,"path":"tags/index.html","permalink":"http://iyue.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS的属性描述符","slug":"JS的属性描述符","date":"2019-12-16T07:21:16.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2019/12/16/JS的属性描述符/","link":"","permalink":"http://iyue.top/2019/12/16/JS%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/","excerpt":"","text":"默认创建对象时属性为数据属性 数据属性字面量创建属性时默认为 123456&#123; value: undefined, writable: true, enumerable: true, configurable: true&#125; Object.defineProperty方法创建属性时默认为 123456&#123; value: undefined, writable: false, enumerable: false, configurable: false&#125; 可以使用Object.getOwnPropertyDescriptor或Object.getOwnPropertyDescriptors方法来获取对象属性的描述符信息； configurable为false,writable为true时，可通过赋值的方式或者Object.defineProperty的方式修改value值； configurable为false,writable为false时，只能通过Object.defineProperty的方式修改value值； configurable为false,writable为true时，可将wirtable设置为false； configurable为false,writable为false时，无法修改wirtable的值； configurable为false后，也无法修改为true； 访问器属性字面量创建访问器属性为 12345const obj=&#123; get a() &#123; return 1 &#125;&#125; Object.defineProperty方法创建访问器属性 123456const obj=&#123;&#125;Object.defineProperty(obj, &#x27;a&#x27; ,&#123; get() &#123; return 1 &#125;&#125;) 默认值为 123456&#123; get: undefined, set: undefined, enumerable: true, configurable: true&#125; 方法 为目标对象设置单个属性设置单个属性可以使用Object.defineProperty()方法，要注意的是，对于同一个属性，不可以同时在描述符中指定属于数据描述符的value，writable和属于访问器描述符的get，set，否则会报错。 为目标对象设置多个属性设置多个属性可以使用Object.defineProperties()方法。 禁止目标对象扩展（不允许添加新属性禁止添加新属性可以使用Object.preventExtensions()方法，该方法接收一个目标对象传入，使用后该对象禁止添加新属性。使该对象禁止扩展。 密封目标对象（不允许扩展且不允许进行属性配置）我们可以使用Object.seal() 方法创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions()方法 并把所有现有属性标记为configurable:false。密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(但是可以修改属性的值) 冻结目标对象（密封对象且不允许修改）Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。","categories":[],"tags":[]},{"title":"页面滚动条的相关属性概念","slug":"页面滚动条的相关属性概念","date":"2019-07-26T08:24:58.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2019/07/26/页面滚动条的相关属性概念/","link":"","permalink":"http://iyue.top/2019/07/26/%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E6%A6%82%E5%BF%B5/","excerpt":"","text":"图例 说明本身的宽高,不包括border clientWidth clientHeight 本身的宽高,包括border offsetWidth offsetHeight 距离左侧和上部的距离,相对于窗口 offsetLeft offsetTop 获取可以滚动的宽度(不包括border)如果内容宽高比本身小,该值为本身宽高,否则就是内容的宽高 scrollWidth scrollHeight 滚动出去的距离 scrollLeft scrollTop 相对于窗口左上角的点 clientX clientY 相对于屏幕左上角的点(建议移动端使用) screenX screenY 相对于本身左上角的点(非标准属性) offsetX offsetY 相对于整个文档左上角的点(建议移动端使用) pageX pageY 获取窗口的宽高 document.body.clientWidth document.body.clientHeight document.body.offsetWidth (border) docuemnt.body.offsetHeight (border) 获取正文的宽高(可以滚动的宽高) document.body.scrollWidth docuemnt.body.scrollHeight 获取正文滚出去的宽高 document.body.scrollTop document.body.scrollLeft 获取屏幕分辨率宽高 window.screen.width window.screen.height 获取左边框宽度和上边框宽度 clientLeft clientTop","categories":[],"tags":[]},{"title":"js中函数的防抖(debounce)与节流(throttle)","slug":"js中函数的防抖-debounce-与节流-throttle","date":"2019-05-22T12:37:27.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2019/05/22/js中函数的防抖-debounce-与节流-throttle/","link":"","permalink":"http://iyue.top/2019/05/22/js%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96-debounce-%E4%B8%8E%E8%8A%82%E6%B5%81-throttle/","excerpt":"","text":"问题在绑定 scroll 、resize 这类事件时，当它发生时，它被触发的频次非常高，间隔很近。如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。加之用户鼠标滚动往往是连续的，就会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响。尤其是在涉及与后端的交互中，前端依赖于某种事件如 resize，scroll，发送 Http 请求，在这个过程中，如果不做防抖处理，那么在事件触发的一瞬间，会有很多个请求发过去，增加了服务端的压力。 函数防抖（debounce）当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。定义如下： 对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如 1000 毫秒）内，事件处理函数只执行一次。 例如：在第一次触发事件时，不立即执行函数，而是给出一个期限值比如 200ms，然后： 如果在 200ms 内没有再次触发滚动事件，那么就执行函数 如果在 200ms 内再次触发滚动事件，那么当前的计时取消，重新开始计时 效果：如果短时间内大量触发同一事件，只会执行一次函数。 实现：既然前面都提到了计时，那实现的关键就在于 setTimeOut 这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现： 1234567891011121314function debounce(fn, delay) &#123; let timer = null; //借助闭包 return function() &#123; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(fn, delay); // 简化写法 &#125;;&#125;function showTop() &#123; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log(&quot;滚动条位置：&quot; + scrollTop);&#125;window.onscroll = debounce(showTop, 1000); // 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置 函数节流（throttle）另一种场景，比如在做图片懒加载的时候，我们是希望一段时间去触发一次，而不是只在最后触发一次。这样我们可以设计一种类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活（类似于技能冷却时间）。 效果：如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。 实现： 123456789101112131415161718192021222324252627282930313233343536// 时间戳方案var throttle = function(func, delay) &#123; var prev = Date.now(); return function() &#123; var context = this; var args = arguments; var now = Date.now(); if (now - prev &gt;= delay) &#123; func.apply(context, args); prev = Date.now(); &#125; &#125;;&#125;;function handle() &#123; console.log(Math.random());&#125;window.addEventListener(&quot;scroll&quot;, throttle(handle, 1000));// 定时器方案var throttle = function(func, delay) &#123; var timer = null; return function() &#123; var context = this; var args = arguments; if (!timer) &#123; timer = setTimeout(function() &#123; func.apply(context, args); timer = null; &#125;, delay); &#125; &#125;;&#125;;function handle() &#123; console.log(Math.random());&#125;window.addEventListener(&quot;scroll&quot;, throttle(handle, 1000)); 总结函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。 区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","categories":[],"tags":[]},{"title":"vue脚手架(vue-cli)由2升级到3时遇到的问题汇总","slug":"vue脚手架-vue-cli-由2升级到3时遇到的问题汇总","date":"2019-04-18T11:50:24.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2019/04/18/vue脚手架-vue-cli-由2升级到3时遇到的问题汇总/","link":"","permalink":"http://iyue.top/2019/04/18/vue%E8%84%9A%E6%89%8B%E6%9E%B6-vue-cli-%E7%94%B12%E5%8D%87%E7%BA%A7%E5%88%B03%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"","text":"问题近期将项目的 vue 脚手架由 2 升级到了 3，在此过程中遇到的一些问题记录如下 案例 vue 挂载方式改变 123456789101112//原方式new Vue(&#123; el: &#x27;#app&#x27;, router, template: &#x27;&lt;App/&gt;&#x27;, components: &#123; App &#125;&#125;)// 现改为new Vue(&#123; router, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) HTML 标签之间的间隙默认被删除，表现为原来在页面上内联元素之间因换行产生的空隙没有了 1234567891011// 由于原项目并没有处理空隙，而且利用了空隙，为保持表现一致，可添加如下配置chainWebpack: config =&gt; &#123; config.module .rule(&#x27;vue&#x27;) .use(&#x27;vue-loader&#x27;) .loader(&#x27;vue-loader&#x27;) .tap(options =&gt; &#123; options.compilerOptions.preserveWhitespace = true return options &#125;)&#125; 3.","categories":[],"tags":[]},{"title":"Chrome72嵌套flex布局修改，你的网站可能会发生布局错乱","slug":"Chrome72嵌套flex布局修改，你的网站可能会发生布局错乱","date":"2019-03-20T12:17:50.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2019/03/20/Chrome72嵌套flex布局修改，你的网站可能会发生布局错乱/","link":"","permalink":"http://iyue.top/2019/03/20/Chrome72%E5%B5%8C%E5%A5%97flex%E5%B8%83%E5%B1%80%E4%BF%AE%E6%94%B9%EF%BC%8C%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%8F%91%E7%94%9F%E5%B8%83%E5%B1%80%E9%94%99%E4%B9%B1/","excerpt":"","text":"作者：蓝博链接：https://juejin.im/post/5c642f2ff265da2de660ecfc来源：掘金 起源2019年1月29日，Chrome72正式版（72.0.3626.81）发布，本次发布带来了一个改变，且没有在更新日志中提及，该改变导致某些网站发生了布局错乱。该改变主要针对的是嵌套的flex布局，下面我们一起看下是怎么回事。 问题首先，我们有一个嵌套的flex布局，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt;div &#123; box-sizing: border-box;&#125;.flex &#123; display: flex; flex-direction: column;&#125;.area &#123; padding: 10px; height: 300px; width: 300px; background-color: #3fb9ab; color: #fff;&#125;.item &#123; padding: 10px; flex: 1; background-color: #158c7e;&#125;.nest-item &#123; flex: 1; overflow: auto; background-color: #046b5f;&#125;.content &#123; padding: 10px; height: 600px;&#125;&lt;/style&gt;&lt;div class=&quot;area flex&quot;&gt; area &lt;div class=&quot;item flex&quot;&gt; item &lt;div class=&quot;nest-item&quot;&gt; &lt;div class=&quot;content&quot;&gt;content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 希望实现这样的效果：父容器area有一个指定的高度，且它是一个flex弹性盒子，它内部有一个子元素item，使用 flex: 1 指定了占满剩余空间，且item也是一个flex弹性盒子，它内部还有一个同样占满剩余空间的嵌套子元素nest-item，通过设置 overflow: auto 让它的内容超出后显示滚动条。效果如下： 这样布局的想法很简单，即通过设置弹性盒子子元素的扩展比率，能得到一个自动占满剩余空间高度的容器，再在这个容器中放需要显示的内容，在某些情况下，这确实是一个比较不错的主意，在Chrome72之前都是可以正常显示的。但是Chrome72.0.3626.81中显示如下： 追溯为什么会出现这样的问题呢？我们看一下规范，flex弹性盒子主轴上子元素的最小大小是内容的大小（视主轴方向为宽或高）。 那么我们再看一下上面的例子，area的主轴是纵向的，子元素item的最小高度即是内容的高度，而nest-item被content撑开，content有一个高度（600px，超出了容器的高度），那么item的最小高度也就超过了600px。这样一来，一层层都是被内容撑开，也就没有出现滚动条了，这样似乎是符合规范预期的。 在chromium的issue反馈中，有人提到了这个问题，根据回复，这正是官方为了让Chrome更加符合规范行为而做的调整。也就是说，Chrome72之前的版本，这算是一个没有按照规范行为而出现的bug。新的调整，其实就是让flex弹性盒子的子元素最小高度的默认行为应用 min-height: min-content ，就像官方回复中提到的那样，让子元素作为flex弹性盒子时却和普通盒子处理方式不同是会让人困惑的。 解决方法既然知道了原因，那么如果我们还想使用这样的布局方式，该怎么做呢？ 对的，我们给item指定一个最小高度，让它不使用默认的行为（即内容的高度），一般我们指定最小高度为0 min-height: 0。给item加上这个样式后，我们再看一下效果： 嗯，已经符合我们的预期了。为了验证规范中提到的对主轴方向的行为，我们修改一下代码，将主轴设置为水平方向试试，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt;div &#123; box-sizing: border-box;&#125;.flex &#123; display: flex; flex-direction: row;&#125;.area &#123; padding: 10px; height: 300px; width: 300px; background-color: #3fb9ab; color: #fff;&#125;.item &#123; padding: 10px; flex: 1; background-color: #158c7e;&#125;.nest-item &#123; flex: 1; overflow: auto; background-color: #046b5f;&#125;.content &#123; padding: 10px; width: 600px;&#125;&lt;/style&gt;&lt;div class=&quot;area flex&quot;&gt; area &lt;div class=&quot;item flex&quot;&gt; item &lt;div class=&quot;nest-item&quot;&gt; &lt;div class=&quot;content&quot;&gt;content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 看来主轴为水平方向时，是符合规范预期行为的（Chrome72及以前的版本都符合），那么我们给item加上一句样式 min-width: 0 ，效果如下： 嗯，是符合我们预期的。 结语好了，现在你已经知道是怎么一回事了，可是等等，你说你升级到Chrome72没有发现我说的问题？ 那是因为官方注意到这个修改会影响到一些网站的正常显示，因此在2019年2月6日（正是春节假期间）发布的Chrome72.0.3626.96中，将这个问题还原回以前的行为了。 官方的意思是为了避免这个修改给某些网站带来的不好的影响，因此预留时间给大家修改，等到Chrome73将会发布这一改变。所以为了未来更好的浏览体验，检查一下你的页面吧！","categories":[],"tags":[]},{"title":"async/await里的并行和串行","slug":"async-await里的并行和串行","date":"2019-02-01T02:24:14.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2019/02/01/async-await里的并行和串行/","link":"","permalink":"http://iyue.top/2019/02/01/async-await%E9%87%8C%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%92%8C%E4%B8%B2%E8%A1%8C/","excerpt":"","text":"文章出处：https://www.cnblogs.com/JRliu/p/9004304.html 问题我们在使用 async/await 语法时，有时会这样用： 1234567891011121314151617181920function getName () &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(&#x27;tony&#x27;) &#125;, 2000) &#125;)&#125;function getId () &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(&#x27;123&#x27;) &#125;, 3000) &#125;)&#125;;(async ()=&gt;&#123; let name = await getName() let id = await getId() alert(`name:$&#123;name&#125;, id:$&#123;id&#125;`)&#125;)() 一眼看上去，应该是3秒种多一点就会 alert 出 ‘name:tony, id:123’，实际上却花费了5秒才出现提示框，她们是串行执行的！而我们想要的是并行执行，因为她们之间并没有依赖关系。串行执行只会白白增加无谓的等待时间！怎么解决呢？ 解决我们先看 Promise 的语法： new Promise( function(resolve, reject) {…} /* executor */ );executor是带有 resolve 和 reject 两个参数的函数 。 Promise构造函数执行时立即 调用executor 函数 ， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。 传给 Promise 作为参数的函数会在 new 创建实例时立即调用上面的代码，可以分解成这样： 1234567;(async ()=&gt;&#123; let namePromise = getName() let name = await namePromise let idPromise = getId() // 2000ms之后才生成 Promise 实例 let id = await idPromise alert(`name:$&#123;name&#125;, id:$&#123;id&#125;`)&#125;)() 所以，如果想并行执行，我们应该先生成所有需要使用的Promise实例： 1234567;(async ()=&gt;&#123; let namePromise = getName() let idPromise = getId() // 先生成所有 promise 实例 let name = await namePromise let id = await idPromise alert(`name:$&#123;name&#125;, id:$&#123;id&#125;`)&#125;)() 或者使用Promise.all 1234;(async ()=&gt;&#123; var result = await Promise.all([getName(), getId()]) alert(`name:$&#123;result[0]&#125;, id:$&#123;result[2]&#125;`)&#125;)()","categories":[],"tags":[]},{"title":"echarts在vue中获取不到高度的问题","slug":"echarts在vue中获取不到高度的问题","date":"2018-11-23T10:21:45.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/11/23/echarts在vue中获取不到高度的问题/","link":"","permalink":"http://iyue.top/2018/11/23/echarts%E5%9C%A8vue%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E9%AB%98%E5%BA%A6%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题引出在项目中，采用了element-ui框架及echarts；模板结构是一个tab切换页中，引入了自己做了简单封装的echarts；在上一版还可以正常显示出图，而在后来对封装的echarts做了简单更新后，图表在tab切换页无法显示出来； 问题排查通过查看element元素发生，图表元素canvas的宽度为0（高度是我自己指定的）；然后在echarts组件中通过apiechartsinstance.getWidth()发现结果为0，说明在echarts实例化的时候，dom元素的宽度为0； echarts的实例化是在vue的mounted阶段进行的，也就是说在这个阶段dom元素没有宽度； 这里还涉及到几个区别； 图表组件更新之前是可以出图的，排查后发现，之前图表实例化是在数据发生变化的时候执行的，而数据是父组件在mounted阶段通过ajax请求获得数据传给echarts子组件的；那么父组件在mounted阶段，dom情况怎么样了呢 改版后，图表实例化只执行一次，是在mounted阶段执行的；而tabs组件有可能在初次渲染时，默认tab页面都是属于隐藏的，从而在这个时候可能没有高度； 以上是改版前后的区别及原因的猜想；其中主要涉及的几个问题； 父组件和子组件的js方法的执行顺序是怎样的？ 通过测试可以知道，执行顺序如下； 父组件created—&gt;子组件created—&gt;子组件mounted—&gt;父组件mounted 如果有多个子组件： 父组件created钩子结束后，依次执行子组件的created钩子多个子组件的created执行顺序为父组件内子组件DOM顺序多个子组件的mounted顺序无法保证，跟子组件本身复杂程度有关父组件一定在所有子组件结束mounted钩子之后，才会进入mounted钩子 以上说法存疑 什么时候才可以获取到dom元素的高度，或者说什么时候dom渲染完成了呢？ 这是一个涉及到生命周期的问题；那么再回去仔细看看关于生命周期的说明;在官方文档中有提到 el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted被调用时 vm.$el 也在文档内。 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted： 12345678mounted: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125; 这样就是相当于，改版前，在父组件的mounted阶段执行请求后得到数据传给子组件，这是一个异步过程，异步是放在最后执行的，然后图表初始化，获得了元素高度； 改版后，是在子元素mounted阶段执行初始化；此时tab中的标签页虽然已存在，但属于隐藏状态，是没有宽度的，此时获取宽度是获取不到的； DOM的修改不会立马导致渲染，渲染线程是在一个独立的线程运行的，但是渲染线程和Javascript线程是互斥的，必须等待Javascript的这次调度执行完或线程挂起了，才能执行渲染；","categories":[],"tags":[]},{"title":"vue项目在国际化中遇到的问题","slug":"vue项目在国际化中遇到的问题","date":"2018-10-12T06:54:47.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/10/12/vue项目在国际化中遇到的问题/","link":"","permalink":"http://iyue.top/2018/10/12/vue%E9%A1%B9%E7%9B%AE%E5%9C%A8%E5%9B%BD%E9%99%85%E5%8C%96%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言由于项目的对外，所以项目需要做国际化，vue项目的国际化自然要用到vue-i18n这个插件，现就国际化中遇到的情况及解决方案整理如下 翻译文本在template中这里的文本会即时替换 翻译文本在实例js中这里的文本由于在首次实例化后就不会再变化，所以需要手动触发一次变化 翻译文本在实例之外的js中mega 开发 鉴于原系统的维护性较差，项目插件引用众多，代码过多冗余，国际化繁琐，开发vue框架的新版mega（框架部分，首页部分内容，中英文国际化）clever_db开发慢查询详情页面改版完成，新版不需要用户选择分时天粒度，","categories":[],"tags":[]},{"title":"vue使用中问题","slug":"vue使用中问题","date":"2018-10-11T07:45:52.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/10/11/vue使用中问题/","link":"","permalink":"http://iyue.top/2018/10/11/vue%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言记录vue在使用中遇到的需要注意的问题 正文 vue-router中路由path值的问题 在嵌套路由使用时，设置path值的时候，注意，如是顶层路由，可以写为/home,即可以加/；在设置二级路由的时候虽然也可以这么写，但就失去了路由层级，在官方文档中有提示： 要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。 vue-router中路由name值的问题 在编程导航的时候，我们可以使用path或者name，使用name的时候发现，name的值不可以重复，就算时平行路由各自的子路由也不能重复name，否则导航发生混乱；","categories":[],"tags":[]},{"title":"常见HTTP状态码解释","slug":"常见HTTP状态码解释","date":"2018-09-13T13:41:56.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/09/13/常见HTTP状态码解释/","link":"","permalink":"http://iyue.top/2018/09/13/%E5%B8%B8%E8%A7%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E8%A7%A3%E9%87%8A/","excerpt":"","text":"1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码。 http状态码 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 http状态码 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx (成功)表示成功处理了请求的状态代码。 http状态码 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 http状态码 201 (已创建) 请求成功并且服务器创建了新的资源。 http状态码 202 (已接受) 服务器已接受请求，但尚未处理。 http状态码 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。 http状态码 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。 http状态码 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。 http状态码 206 (部分内容) 服务器成功处理了部分 GET 请求。 3xx (重定向)表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 http状态码 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 http状态码 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 http状态码 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 http状态码 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 http状态码 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 http状态码 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 http状态码 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx(请求错误)这些状态代码表示请求可能出错，妨碍了服务器的处理。 http状态码 400 (错误请求) 服务器不理解请求的语法。 http状态码 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 http状态码 403 (禁止) 服务器拒绝请求。 http状态码 404 (未找到) 服务器找不到请求的网页。 http状态码 405 (方法禁用) 禁用请求中指定的方法。 http状态码 406 (不接受) 无法使用请求的内容特性响应请求的网页。 http状态码 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。 http状态码 408 (请求超时) 服务器等候请求时发生超时。 http状态码 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 http状态码 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 http状态码 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 http状态码 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 http状态码 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 http状态码 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。 http状态码 415 (不支持的媒体类型) 请求的格式不受请求页面的支持。 http状态码 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。 http状态码 417 (未满足期望值) 服务器未满足”期望”请求标头字段的要求。 5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 http状态码 500 (服务器内部错误) 服务器遇到错误，无法完成请求。 http状态码 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 http状态码 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。 http状态码 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。 http状态码 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 http状态码 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。 总结我们访问网站最常遇到的状态码，200代表请求成功，304是未修改(缓存)，403服务器拒绝(文件夹权限问题)，404请求失败，文件不存在(路径不存在)，500是服务器错误，通常代表服务器没法处理此请求或者服务器挂掉了，503是请求无响应，通常是服务器资源没法分配处理，网站被攻击的会经常遇到503错误的。了解这些状态码代表的含义，可以帮助你快速的定位网站遇到的故障问题。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://iyue.top/tags/http/"}]},{"title":"网址最后的斜杠问题","slug":"网址最后的斜杠问题","date":"2018-09-13T12:44:13.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/09/13/网址最后的斜杠问题/","link":"","permalink":"http://iyue.top/2018/09/13/%E7%BD%91%E5%9D%80%E6%9C%80%E5%90%8E%E7%9A%84%E6%96%9C%E6%9D%A0%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题许多网站的访问在网址后面有时会带一个‘/’，有时没有，但经常带不带都访问的都是同一个网页；最近在用django的时候发现这个问题；现记录下来。 表现在django的框架下，访问路由地址的时候，如果你的路由地址配置为如下这种 1url(r&#x27;^user/$&#x27;, &#x27;get_user_info&#x27;) 框架默认会将不带斜杠的路由重定向到带斜杠的路由下，这是访问***.com/user和***.com/user/都可以； 如果配置为 1url(r&#x27;^user$&#x27;, &#x27;get_user_info&#x27;) 这在访问***.com/user时没有问题，访问***.com/user/时就会报404错误。 注意的是，这种重定向会被浏览器记住，当你改变配置为不带斜杠的时候，继续访问浏览器会被重定向到带斜杠的地址，而发生404错误； 原因django的配置文件settings.py中，默认的设置(该配置未显式写出)为Ture; 1APPEND_SLASH = True 指示不带斜杠的情况下会重定向到带斜杠的地址；如果设置为False,就不会重定向；","categories":[],"tags":[{"name":"django","slug":"django","permalink":"http://iyue.top/tags/django/"}]},{"title":"XSS与CSRF","slug":"XXS与CSRF","date":"2018-09-07T12:18:20.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/09/07/XXS与CSRF/","link":"","permalink":"http://iyue.top/2018/09/07/XXS%E4%B8%8ECSRF/","excerpt":"","text":"引言针对前端安全，主要有XSS跨站脚本攻击，CSRF跨站伪造请求，SQL注入等，今天主要讨论下关于前两种 XSS跨站脚本攻击更多具体详细的解释可以查看XSS（跨站脚本攻击）的最全总结 XSS攻击通常被分为两类：存储型和反射型。还有第三类，和基于DOM的xss；下面我们不说定义直接看看怎么操作 反射型 一般有搜索框的网站，在搜索东西的时候会在结果页呈现你搜索的字符； 比如你搜索笔记本电脑，网站会提示你搜索“笔记本电脑”的结果如下，这说明用户的输入在页面上有了呈现；那么我们输入一段恶意脚本，也许也会原样输出执行，比如我们输入 1&lt;script&gt;alert(1)&lt;/script&gt; 恶意代码就是你可以放一段脚本，比较加入一个js文件请求，在js代码里来获取cookie等用户信息，并发送给自己；但用户并不会自己输入恶意脚本，那么就通过邮件等方式，让用户点击搜索结果连接，以达到脚本注入的目的； 当然基本上没什么网站会有这么明显的漏洞，这里只是演示说如何实现反射型攻击。 存储型 这种一般常出现在用户可输入，然后在网站动态展示，大家都能看到的网站，如微博，社区，评论等地方；常见的做法就是发一段脚本到输入区，网站会记录下来并动态的渲染在页面上，只要访问的用户都能看到；由于这种情形注入的脚本被写到了服务器数据库中，所以叫存储型攻击； 基于DOM 这种攻击的前提是易受攻击的网站有一个HTML页面采用不安全的方式从document.location 或document.URL 或 document.referrer获取数据（或者任何其他攻击者可以修改的对象），也就是说恶意代码直接来自这些可任意被修改的对象；详细可查看基于 DOM 的第三类跨站脚本 XSS 如上，一般只要这个网站某个页面将用户的输入包含在它生成的动态输出页面中并且未经验证或编码转义，这个缺陷就存在。 防范方法 所有前端的页面渲染，尽量使用ajax异步进行，从后台获取要显示的数据。 前端提交过来的数据，在后台入口处统统对HTML中的关键字进行html编码转义。 CSRF更多具体详细的解释可以查看邪恶的CSRF – superfish CSRF叫跨域伪造请求，其实就是模拟用户操作，就是在A网站登录的情况下，B网站可以发起A网站发起的请求；要达成这个目的就需要解决跨域的问题； 传统的ajax都有跨域的限制，但如发起get请求就很方便，以打开url的方式，jsonp的方式，请求三方资源的方式，都可以达成目的； 而采用原生表单的提交方式，可以发起post跨域请求；","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://iyue.top/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"http://iyue.top/tags/CSRF/"}]},{"title":"单点登录的实现方式","slug":"单点登录的实现方式","date":"2018-09-06T13:02:01.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/09/06/单点登录的实现方式/","link":"","permalink":"http://iyue.top/2018/09/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","excerpt":"","text":"该篇文章很多段落来自单点登录原理与简单实现，大家可以先拜读这篇文章，这篇文章讲述十分详细，我这里只是插了一些自己的疑虑，而且可能还说的不是很清楚，权当自己做个笔记了 单系统登录机制 http无状态协议 http作为通信协议，是无状态的，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联。 但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。 会话机制 浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了。 这里有个session和cookie的区别；其实session算是cookie的变种；因为本身的机制形式并没有变，依然是需要浏览器有一个信息串和服务器得会话对象所对应，只不过早先得cookie是在浏览器端保存得用户的信息，服务器通过这些信息来识别用户，而session方式是把信息保存在了服务器端，然后生成一个session的id字符串存在了cookie，相对之前的做法安全一些；但本质未发生变化。 当然，浏览器但端的信息其实不是必须存在cookie里，也可以放在localstotage或者其他可存的地方，这样防止从cookie得到敏感信息，但这样就需要前端做一个手工处理，将这个id发送给服务器端；目前大多的系统还是主要以cookie来存储的，一是读写cookie浏览器可以自动完成，二是在单点登录系统时可以帮其他子应用自动登录。 登录状态 有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态。 个人理解，http是无状态的，那么每个受限请求都是需要验证的，那么前端传来的id只要可以对应后端的session，那么就是合法的，所以不太清楚后端是否还要做一个会话标记的操作； 多系统的复杂性web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。 单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie。也就是说A应用登录后，打开B应用，B是拿不到A的cookie的。 这时我们就将web应用群中所有子系统的域名统一在一个顶级域名下，在顶级域名下设置的cookie，其子域名是可以访问其cookie的。 这里有个cookie设置的规则（有点儿像全局作用域和子作用域）：设置cookie只可以向上设置，可设置本级域名，或者向上的域名；比如顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名等等，否则cookie无法生成；二级域名可以设置本域及顶级域；获取cookie只可以向上获取，可获取本级域名，或者向上的域名；比如顶级域名只能获取到domain设置为顶级域名的cookie，domain设置为其他子级域名的无法获取；二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。总的来说，顶级域名设置的cookie可以共享【需要指定domain主域名的host】给二级域名，也可以自己私有【不指定domain】 这里云平台系统采用的就是这种方式，sessionid由统一认证系统生成，并写到顶级域名下面，其余子系统通过访问cookie获取该id与统一认证系统进行权限验证；不过这里是子系统通过统一认证系统生成的token然后在服务端去统一认证系统换取sessionid，由子系统写到cookie里的顶级域名下的，不太清楚这一步是什么意思；这样，各个子系统的共享统一生成的sessionid，并且每个受限请求都去找认证系统授权；这种方式也很方便的可以做到统一登出，只要使统一认证系统的session失效就可以了。 然而，可行并不代表好，共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。 因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。 单点登录这里说的单点登录，是指有一个统一认证中心，可实现一处登录，全都登录，一处登出，全部登出，并且不局限与同一个顶级域名下。 单点登录的简单流程如下图： 其中有两个主要注意的地方，就是在认证中心登录的时候，会帮其他子系统都登录，登出的时候会帮其他子系统都登出；另外子系统的sessionid是各自维护还是统一有认证系统维护； 统一登录登出机制 在统一认证中心登录后，可以以跨域访问的形式，将统一的生成的token，逐个发送给各个子系统，子系统收到后向认证中心认证token，认证通过后可以给自己系统下写入cookie，这样，在访问其他子系统的时候，请求会带上之前写的cookie，从而打开子系统即为登录状态； 在子系统登出时会跳转到登录页面，此时可以以跨域访问的形式，逐个访问各个子系统请求，这些请求会携带各自域名下的sessionid，子系统就会注销该id，完成各个子系统的登出； sessinid维护方式 如果各自维护sessionid，登录的时候不通知子系统的话，打开其他子系统的时候会有一个重定向到认证中心获取状态的过程；通知了的话就无需重定向了；在登出的时候认证中心必须去通知各个子系统登出，不然子系统无法知道已登出； 如果认证系统统一维护sessionid的话，登录不通知也会去重定向；登出就不必通知了。 如金融的sso认证系统便没有去通知其他子系统登录状态，在访问子系统的时候会重定向到认证地址，认证地址根据cookie信息，确认已登录后，将token带在请求上，重定向回子系统，子系统拿到token后去认证中心通过后再写sessionid，这样会有一个重定向url变更的过程；而登出的时候，由于并未通知其他子系统，所以登出无法做到统一登出；不过，此处既然没有做统一登出，那么在登录的时候也不应该去通知子系统去登录；这样这个系统其实算是个统一认证中心，不算严格意义的单点登录。 通知其他子系统登录登出的形式 由于域名不同，通知其他子系统只能以跨域的形式去访问各自的服务器；可以以jsonp的形式,也可以是cors的形式，或者其他跨域方式，但需要将统一认证生成的token信息手动加到请求中，因为跨域请求不会携带本域的cookie信息。","categories":[],"tags":[{"name":"cookie","slug":"cookie","permalink":"http://iyue.top/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://iyue.top/tags/session/"}]},{"title":"django的跨域请求设置","slug":"django的跨域请求设置","date":"2018-09-06T03:26:30.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/09/06/django的跨域请求设置/","link":"","permalink":"http://iyue.top/2018/09/06/django%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"问题引出由于django本身的权限管理是基于cookie来认证的，而整个过程并不需要前端做什么，直接后端完成；但跨域的时候，产生几个问题； django如何跨域？ django跨域后可以正常的写入cookie吗？ 其实，跨域实现的方法有很多种，可以查看前端常见跨域解决方案（全），在此我们使用cors跨域的方式 cors跨域概述浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request） 相关内容可以参考跨域CORS原理及调用具体示例 引起我们注意的一点就是同为post请求，当Content-Type的值为application/json时，就变成了非简单请求，基础表现就是浏览器会先发一个”预检”请求 django跨域设置 执行安装 12# https://github.com/ottoyiu/django-cors-headers/pip install django-cors-headers 配置settings.py 123456789101112131415161718192021INSTALLED_APPS = ( ... &#x27;corsheaders&#x27;, ...)...MIDDLEWARE = [ # Or MIDDLEWARE_CLASSES on Django &lt; 1.10 ... &#x27;corsheaders.middleware.CorsMiddleware&#x27;, &#x27;django.middleware.common.CommonMiddleware&#x27;, ...]...# cookies will be allowed to be included in cross-site HTTP requestsCORS_ALLOW_CREDENTIALS = True # If True, the whitelist will not be used and all origins will be acceptedCORS_ORIGIN_ALLOW_ALL = False# A list of origin hostnames that are authorized to make cross-site HTTP requestsCORS_ORIGIN_WHITELIST = ( &#x27;localhost:8888&#x27;) 显式设置cookie1234567891011# view.pydef test(request): if request.method == &#x27;POST&#x27;: data = &#123; &#x27;code&#x27;: 0, &#x27;msg&#x27;: &#x27;this is a test&#x27;, &#x27;data&#x27;: &#x27;POST&#x27; &#125; rep = HttpResponse(json.dumps(data, cls=CJsonEncoder), content_type=&quot;application/json&quot;) rep.set_cookie(&#x27;key&#x27;, &#x27;value&#x27;) return rep 前端设置前端默认不允许跨域携带cookies，需进行显式的设置；不同的库可能有一些细微的差别； 需要注意的是，以原生表单的形式，发起post请求，是可以携带cookie自动跨域的，无需其他设置；form表单可以跨域一个是历史原因要保持兼容性，一个是form表单会刷新页面不会把结果返回给js，所以相对安全，但其实请求已经发送出去了，你只是拿不到响应而已；这个问题会引起CSRF攻击； 1234567891011121314151617181920// 原生js（亲测可用，其余未作测试）var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;, &quot;http://localhost:8000/api/test/&quot;, true); xhr.withCredentials = true; //支持跨域发送cookiesxhr.send();// jQuery$.ajax(&#123; type: &quot;POST&quot;, url: &quot;http://localhost:8000/api/test/&quot;, dataType: &#x27;jsonp&#x27;, xhrFields: &#123;withCredentials: true&#125;, crossDomain: true,&#125;)// axios（vue常用的方案）axios.create(&#123; timeout: 5000, withCredentials: true // 允许携带cookie&#125;) 突然来的疑问写到此时，我所作的测试都是在本地测的，服务器端在localhost:8000,前端在localhost:8888;而跨域操作所写的cookie均在localhost之下，这样就有一个问题，跨域读写的cookie到底是哪里？是发起请求页的域还是请求地址的域？ 解答疑问我们得到的答案是cors跨域读写的cookie都是请求地址的cookie；比如我们请求第三方cdn，并不会携带本站的cookie，发送跨域请求也一样，只会携带请求指向地址的域的cookie。（这也是跨站伪造请求csrf的原理） 服务器如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 如果非要跨域写cookie呢？有什么办法吗？ 跨域写本域cookie查到的方法如下：可以通过ngix反向代理跨域配置：proxy_cookie_domain b.com a.com;也可以通过中间件http-proxy-middleware代理跨域时，配置加上cookieDomainRewrite: ‘a.com’参数，都是用来修改转发过来的cookie中域名为当前a.com域，所以实现了a.com下cookie写入。","categories":[],"tags":[{"name":"django","slug":"django","permalink":"http://iyue.top/tags/django/"},{"name":"跨域","slug":"跨域","permalink":"http://iyue.top/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"cookie","slug":"cookie","permalink":"http://iyue.top/tags/cookie/"}]},{"title":"post请求的提交数据的几种方式","slug":"post请求的提交数据的几种方式","date":"2018-09-05T12:00:13.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/09/05/post请求的提交数据的几种方式/","link":"","permalink":"http://iyue.top/2018/09/05/post%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"前言HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。 个人理解：get请求其实就是将参数以key=value&amp;key=value的形式拼在url发往服务器，所以get请求没有那么多复杂的说法；而post请求规定提交的数据必须放在消息主体（entity-body）中，但没有对形式的规定，所以就有了各种各样的方式； 引出问题1234567891011121314151617181920212223var ajax = new XMLHttpRequest();var data1 = &#x27;&#123;&quot;arr&quot;:[1,2,3,4,5],&quot;test&quot;:&quot;name&quot;&#125;&#x27;var data2 = &#x27;name=jack&amp;age=998&#x27;// 使用post请求ajax.open(&#x27;post&#x27;, &#x27;http://localhost:8000/api/test/&#x27;);// 如果 使用post发送数据 必须 设置 如下内容// 修改了 发送给 服务器的 请求报文的 内容// 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。// 然后在 send() 方法中规定您希望发送的数据：ajax.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);// 发送// post请求 发送的数据 写在 send方法中// 格式 name=jack&amp;age=18 字符串的格式;// 不能直接发送一个对象，否则后端会变成[object Object]ajax.send(data2);// 注册事件ajax.onreadystatechange = function () &#123; if (ajax.readyState == 4 &amp;&amp; ajax.status == 200) &#123; console.log(ajax.responseText); &#125;&#125; 需要注意的是，ajax.send()的内容可以是data1的格式（JSON.stringfy()得来），也可以是data2的格式（qs.stringfy()得来），两种的方式都可以； 另外ajax.send()不能直接发送对象，后端接受会变成[object Object]，而对于axios库，直接发送对象，它会自动转成json字符串； 在后端为django的代码中测试 12345678910def test(request): if request.method == &#x27;POST&#x27;: print request.POST.get(&#x27;arr&#x27;) print request.body data = &#123; &#x27;code&#x27;: 0, &#x27;msg&#x27;: &#x27;this is a test&#x27;, &#x27;data&#x27;: &#x27;POST&#x27; &#125; return HttpResponse(json.dumps(data, cls=CJsonEncoder), content_type=&quot;application/json&quot;) 如何是data1的格式就是json字符串的话，request.POST是无法获取到东西的，data2格式通过request.POST是可以获取到的，但前提是请求的Content-type必须设置为application/x-www-form-urlencoded,否则都获取不到结果，只能从request.body中获得原始数据；之所以这样是因为django框架在处理响应时，只对Content-type为application/x-www-form-urlencoded的情况做了处理，（具体可以查看django的源码中class HttpRequest(object)对post的处理部分）django之所以这么做，是因为什么呢？下面先说一下关于post的几种请求方式 application/x-www-form-urlencoded这是post的默认请求方式，在post请求不设置Content-type时的默认值； 123456&lt;form action=&quot;http://localhost:8000/api/test/&quot; method=&quot;post&quot;&gt; First name:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;Mickey&quot;&gt;&lt;br&gt; Last name:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;lastname&quot; value=&quot;Mouse&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 这也是原始提交表单的方式，在表单提交的方式里，浏览器会把表单里的数据，以key=value&amp;key=value的形式发送给服务器；个人理解，由于这种最初的提交方式,决定了application/x-www-form-urlencoded下对数据的处理;所以，在ajax请求的年代，其实传哪种（data1和data2）格式都可以，不同的是，服务器是以Content-type的类型来决定如何处理数据的； 这种post的类型的时候可以向服务器发送数据，而数据的格式应为键值对key=value&amp;key=value，js对象可以通过qs.stringfy()来序列化得到;不过，qs在序列化数组的时候默认会序列化为arr[]=value&amp;arr[]=value的形式；这时需要配置下qs，指定数组的编码格式；否则后端获取不到该数组； django接收数组的时候用request.POST.getlist();如果前端序列化带了[]，后端也需要带，或者要前端序列化的时候去掉[]； 指定数组的编码格式和对应的结果 12345678910111213141516171819202122let params = [1, 2, 3];// indices(默认)qs.stringify(&#123;a: params&#125;, &#123; arrayFormat: &#x27;indices&#x27;&#125;)// 结果是&#x27;a[0]=1&amp;a[1]=2&amp;a[2]=3&#x27;// brackets qs.stringify(&#123;a: params&#125;, &#123; arrayFormat: &#x27;brackets&#x27;&#125;)// 结果是&#x27;a[]=1&amp;a[]=2&amp;a[]=3&#x27;// repeatqs.stringify(&#123;a: params&#125;, &#123; arrayFormat: &#x27;repeat&#x27;&#125;)// 结果是&#x27;a=1&amp;a=2&amp;a=3&#x27; application/json这种方式就是告诉服务器，传输的数据为json字符串，所以对应的数格式应为json字符串，js对象可以通过JSON.stringfy()来序列化得到；这是一种略新的格式，可能早期的ie等浏览器不支持 如果发送对象比较复杂比如[&#123;&quot;id&quot;:&quot;001&quot;,&quot;name&quot;:&quot;小明&quot;&#125;,&#123;&quot;id&quot;:&quot;002&quot;,&quot;name&quot;:&quot;小军&quot;&#125;]；这时候还是简单的用json字符串为好，表单提交的方式可能会造成后端解析困难的情况，另外也很难看懂结果; multipart/form-data这种类型主要用来上传文件（可上传多个），也可以发送键值对；（该内容后续展开） text/plain (text/json/xml/html)数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符。postman软件里标的是RAW,application/json包含在RAW里； binary暂没用过，只在postman中看到过，相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。","categories":[],"tags":[{"name":"django","slug":"django","permalink":"http://iyue.top/tags/django/"},{"name":"http","slug":"http","permalink":"http://iyue.top/tags/http/"},{"name":"post","slug":"post","permalink":"http://iyue.top/tags/post/"}]},{"title":"js变量在内存的存放解惑","slug":"js变量在内存的存放解惑","date":"2018-08-24T11:56:56.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/08/24/js变量在内存的存放解惑/","link":"","permalink":"http://iyue.top/2018/08/24/js%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E6%94%BE%E8%A7%A3%E6%83%91/","excerpt":"","text":"js变量的类型我们知道js变量有两种类型 基本类型值，指简单的数据段，对于undefined、null、boolean、number、string这5种简单数据类型可以直接操作保存在变量中的实际值，也就是按值访问。 引用类型值，指那些可能由多个值构成的对象，只能操作对象的引用而不是实际的对象，所以要得到引用类型这种值只能按引用访问。 变量的存放方式有如下代码段（赋值基本类型） 12var a=1;var b=1; 上述代码定义了两个变量，定义a=1在栈内存开辟一块空间存放1这个值，同理定义b=1也开辟一块内存存放1这个值；当修改变量的值的时候，比如重新赋值a=3，那么就会重新开辟一块内存，将3存入后，把a指向3所在的内存位置； 有个问题还没考证，就是不同的变量定义的值一样的时候，是不是指向的是同一块内存。在python中可以通过id来访问存放位置的id，在值（基本类型）较小的时候，就是指向同一块内存 有如下代码段（赋值引用类型） 12var c=&#123;name:&#x27;阿Q&#x27;&#125;;var d=&#123;name:&#x27;阿Q&#x27;&#125;; 上述代码定义了两个变量，定义c的时候在栈内存开辟一块空间存放一个内存地址，这个内存地址指向堆内存中放&#123;name:&#39;阿Q&#39;&#125;这个对象的内存；d同样如此，而且两个对象是毫无关系的，他们的内存地址是不一样的。当修改变量的值的时候，如c=&#123;name:&#39;老王&#39;&#125;，这种情况就和基本类型一样，属于重新赋值，就会将对象&#123;name:&#39;老王&#39;&#125;存到堆内存中，将对象的地址存到栈内存中，c指向这个内存；当修改变量，如c.name=&#39;老张&#39;，这种情况可以看作给对象做一个修正或者扩展，不属于重新赋值，虽然结果是修改了对象，但并没有改动对象所在的位置，即c指向的栈内存里存放的对象的地址并没有变；当然如果如下定义 123var c=d=&#123;name:&#x27;阿Q&#x27;&#125;;// 或者var a=b=1; 这样的连等赋值，有另外的说法，之后专写一篇关于连等赋值的问题。 函数传参是按值传递还是引用传递对于这块内容，网上很多博文说法很多，还有说共享传递啥的，在此我们不对这些字面进行讨论，我们就解释下本质到底是怎么个情况。比如有如下代码 123456var a = 1;function foo(x) &#123; x = 2;&#125;foo(a);console.log(a); // 仍为1, 未受x = 2赋值所影响 这个就无需多解释了，x作为一个形参，只在函数内部生效，而且当a当作参数传给x的时候，其实就是复制了一份a指向的栈内存中存放的值，所以a和x就是毫无关系了如果a为一个引用类型，如下代码 123456var obj = &#123;x : 1&#125;;function foo(o) &#123; o.x = 3;&#125;foo(obj);console.log(obj.x); // 3, 被修改了! 此处也一样，x作为一个形参，当obj当作参数传给o的时候，其实是复制了一份obj指向的栈内存中存放的对象的地址，所以obj和o在栈内存中是不一样的，但在栈内存中存的东西是一样的，就是对象&#123;x : 1&#125;所在的地址；所以当修改o的时候，自然obj也就被修改了还有人提出以下代码 123456var foo = &#123;name:&#x27;foo&#x27;&#125;;function test(o)&#123; o = &#123;name:&#x27;bar&#x27;&#125;; &#125;test(foo);console.log(foo.name); // foo，未被修改； 这个结果是没问题的，但这就是上文提到的对对象的修改的方式的问题，是直接赋值去修改变量，还是去修改对象的属性；上述代码foo当作参数传给o，同样将对象所在地址赋值一份给了形参o，但函数中o的赋值操作，使形参o完全指向了另外一个对象的内存地址，这个操作，并不影响实参foo在内存中存放的地址，及地址所指向的对象； 参考资料JS中函数的参数是按值传递还是按引用传递JavaScript参数按值传递的理解JS进阶系列之内存空间","categories":[],"tags":[{"name":"值类型","slug":"值类型","permalink":"http://iyue.top/tags/%E5%80%BC%E7%B1%BB%E5%9E%8B/"}]},{"title":"你不知道的JavaScript-第一部分","slug":"js中的作用域","date":"2018-08-22T12:08:24.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/08/22/js中的作用域/","link":"","permalink":"http://iyue.top/2018/08/22/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"本文转自ZengTianShengZ，您可以直接去原处阅览 第一章： 作用域是什么1、 编译原理JavaScript 被列为 ‘动态’ 或 ‘解释执行’ 语言，于其他传统语言（如 java）不同的是，JavaScript是边编译边执行的。一段源码在执行前会经历三个步骤： 分词/词法分析 -&gt; 解析/语法分析 -&gt; 代码生成 分词/词法分析 这个过程将字符串分解成词法单元，如 var a = 2; 会被分解成词法单元 var、 a、 = 、2、;。空格一般没意义会被忽略 解析/语法分析 这个过程会将词法单元转换成 抽象语法树（Abstract Syntax Tree,AST）。 如 var a = 2; 对应的 抽象语法树 如下, 可通过 在线可视化AST 网址在线分析 12345678910111213141516171819202122232425262728293031323334&#123; &quot;type&quot;: &quot;Program&quot;, &quot;start&quot;: 0, &quot;end&quot;: 10, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclaration&quot;, &quot;start&quot;: 0, &quot;end&quot;: 10, &quot;declarations&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;start&quot;: 4, &quot;end&quot;: 9, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;start&quot;: 4, &quot;end&quot;: 5, &quot;name&quot;: &quot;a&quot; &#125;, &quot;init&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;start&quot;: 8, &quot;end&quot;: 9, &quot;value&quot;: 2, &quot;raw&quot;: &quot;2&quot; &#125; &#125; ], &quot;kind&quot;: &quot;var&quot; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 代码生成 将 AST 转换成可执行的代码，存放于内存中，并分配内存和转化为一些机器指令 2、理解作用域其实结合上面提到的编译原理，作用域就好理解了。作用域就是当前执行代码对这些标识符的访问权限。编译器会在当前作用域中声明一些变量，运行时引擎会去作用域中查找这些变量（其实就是一个寻址的过程），如果找到这些变量就可以操作变量，找不到就往上一层作用域找（作用域链的概念），或者返回 null 第三章： 函数作用域和块作用域1、函数中的作用域每声明一个函数都会形成一个作用域，那作用域有什么用呢，它能让该作用域内的变量和函数不被外界访问到，也可以反过来说是不让该作用域内的变量或函数污染全局。 对比： 1234var a = 123function bar() &#123; //...&#125; 和 123456function foo() &#123; var a = 123 function bar() &#123; //... &#125;&#125; 变量 a 和函数 bar 用一个函数 foo 包裹起来，函数 foo 会形成一个作用域，变量 a 和函数 bar 外界将无法访问，同时变量或函数也不会污染全局。 2、函数作用域进一步思考，上面例子的变量 a 和函数 bar 有了作用域，但函数 foo 不也是暴露在全局，也对全局造成污染了啊。是的，JavaScript对这种情况提出了解决方案： 立即执行函数 (IIFE) 123456(function foo() &#123; var a = 123 function bar() &#123; //... &#125;&#125;)() 第一个（）将函数变成表达式，第二个（）执行了这个函数，最终函数 foo 也形成了自己的作用域，不会污染到全局，同时也不被全局访问的到。 3、块作用域es6之前JavaScript是没有块作用域这个概念的，这与一般的语言（如Java ，C）很大不同，看下面这个例子： 1234for (var i = 0; i &lt; 10; i++) &#123; console.log(&#x27;i=&#x27;, i);&#125;console.log(&#x27;输出&#x27;, i); // 输出 10 for 循环定义了变量 i，通常我们只想这个变量 i 在循环内使用，但忽略了 i 其实是作用在外部作用域(函数或全局)的。所以循环过后也能正常打印出 i ,因为没有块的概念。 甚至连 try/catch 也没形成块作用域: 123456try &#123; for (var i = 0; i &lt; 10; i++) &#123; console.log(&#x27;i=&#x27;, i); &#125;&#125; catch (error) &#123;&#125;console.log(&#x27;输出&#x27;, i); // 输出 10 解决方法1 形成块作用域的方法当然是使用 es6 的 let 和 const 了， let 为其声明的变量隐式的劫持了所在的块作用域。 1234for (let i = 0; i &lt; 10; i++) &#123; console.log(&#x27;i=&#x27;, i);&#125;console.log(&#x27;输出&#x27;, i); // ReferenceError: i is not defined 将上面例子的 var 换成 let 最后输出就报错了 ReferenceError: i is not defined ，说明被 let 声明的 i 只作用在了 for 这个块中。 除了 let 会让 for、if、try/catch 等形成块，JavaScript 的 &#123;&#125; 也能形成块 12345&#123; let name = &#x27;曾田生&#x27;&#125;console.log(name); //ReferenceError: name is not defined 解决方法2 早在没 es6 的 let 声明之前，常用的做法是利用 函数也能形成作用域 这么个概念来解决一些问题的。 看个例子 1234567891011121314function foo() &#123; var result = [] for (var i = 0; i &lt; 10; i++) &#123; result[i] = function () &#123; return i &#125; &#125; console.log(i）// i 作用在整个函数，for 执行完此时 i 已经等于 10 了 return result&#125;var result = foo()console.log(result[0]()); // 输出 10 期望 0console.log(result[1]()); // 输出 10 期望 1console.log(result[2]()); // 输出 10 期望 2 这个例子出现的问题是执行数组函数最终都输出了 10， 因为 i 作用在整个函数，for 执行完此时 i 已经等于 10 了, 所以当后续执行函数 result[x]() 内部返回的 i 已经是 10 了。 利用函数的作用域来解决 123456789101112131415function foo() &#123; var result = [] for (var i = 0; i &lt; 10; i++) &#123; result[i] = function (num) &#123; return function () &#123; // 函数形成一个作用域，内部变量被私有化了 return num &#125; &#125;(i) &#125; return result&#125;var result = foo()console.log(result[0]()); // 0console.log(result[1]()); // 1console.log(result[2]()); // 2 上面的例子也是挺典型的，一般面试题比较考基础的话就会被问道，上面例子不仅考察到了块作用域的概念，函数作用域的概念，还考察到了闭包的概念（闭包后续讲但不影响这个例子的理解），多琢磨一下就理解了。 第四章： 提升提升指的是变量提升和函数提升，为什么JavaScript会有提升这个概念呢，其实也很好理解，因为JavaScript代码是先 编译 后 执行 的，所以在编译阶段就会先对变量和函数做声明，在执行阶段就出现了所谓的变量提升和函数提升了。 1、变量提升12console.log(a); // undefinedvar a = 1; 上面代码 console.log(a); // undefined 就是因为编译阶段先对变量做了声明,先声明了个变量 a, 并默认赋值 undefined 123var a;console.log(a); // undefineda = 1; 2、函数提升函数同样也存在提升，这就是为什么函数能先调用后声明了 1234foo();function foo() &#123; console.log(&#x27;---foo----&#x27;);&#125; 注意:函数表达式不会被提升 12345foo();var foo = function() &#123; console.log(&#x27;---foo----&#x27;);&#125;// TypeError: foo is not a function 注意：函数会首先被提升，然后才是变量 123456var foo = 1;foo();function foo() &#123; console.log(&#x27;---foo----&#x27;);&#125;// TypeError: foo is not a function 分析一下，因为上面例子编译后是这样的 1234567var foo = undefined; // 变量名赋值 undefinedfunction foo() &#123; // 函数先提升 console.log(&#x27;---foo----&#x27;);&#125;foo = 1; // 但接下去是变量被重新赋值了 1，是个Number类型foo(); // Number类型当然不能用函数方式调用，就报错了// TypeError: foo is not a function 第五章： 作用域闭包闭包问题一直会在JavaScript被提起，是JavaScript一个比较奇葩的概念 1、闭包的产生 闭包的概念： 当函数可以记住并访问所在的词法作用域时，就产生了闭包 概念貌似挺简单的，简单分析下，首先闭包是 产生的，是在代码执行中产生的，有的一些网络博文直接将闭包定义为 某一个特殊函数 是错的。 闭包是怎么产生的呢，一个函数能访问到所在函数作用域就产生了闭包，注意到作用域的概念，咱们最上面的章节有提到，看下面例子： 12345678910111213function foo() &#123; var a = 0; function bar() &#123; a++; console.log(a); &#125; return bar;&#125;var bat = foo()bat() // 1bat() // 2bat() // 3 结合例子分析一下： 函数 foo 内部返回了函数 bar ,外部声明个变量 bat 拿到 foo 返回的函数 bar ，执行 bat() 发现能正常输出 1 ，注意前面章节提到的作用域，变量 a 是在函数 foo 内部的一个私有变量，不能被外界访问的，但外部函数 bat 却能访问的到私有变量 a，这说明了 外部函数 bat 持有函数 foo 的作用域 ，也就产生了闭包。 闭包的形成有什么用呢，JavaScript 让闭包的存在明显有它的作用，其中一个作用是为了模块化，当然你也可以利用外部函数持有另一个函数作用域的闭包特性去做更多的事情，但这边就暂且讨论模块化这个作用。 函数有什么作用呢，私有化变量\b或方法呀，那函数内的变量和方法被私有化了函数怎么和外部做 交流 呢, 暴露出一些变量或方法呀 123456789101112131415161718192021function foo() &#123; var _a = 0; var b = 0; function _add() &#123; b = _a + 10 &#125; function bar() &#123; _add() &#125; function getB() &#123; return b &#125; return &#123; bar: bar, getB: getB &#125;&#125;var bat = foo()bat.bar()bat.getB() // 10 上面例子函数 foo 可以理解为一个模块，内部声明了一些私有变量和方法，也对外界暴露了一些方法，只是在执行的过程中顺带产生了一个闭包 2、模块机制上面提到了闭包的产生和作用，貌似在使用 es6语法 开发的过程中很少用到了闭包，但实际上我们一直在用闭包的概念的。 foo.js 123456789101112131415var _a = 0;var b = 0;function _add() &#123; b = _a + 10&#125;function bar() &#123; _add()&#125;function getB() &#123; return b&#125;export default &#123; bar: bar, getB: getB&#125; bat.js 1234import bat from &#x27;foo&#x27;bat.bar()bat.getB() // 10 上面例子是 es6 模块的写法，是不是惊奇的发现变量 bat 可以记住并访问模块 foo 的作用域，这符合了闭包的概念。 小结：本章节我们深入理解了JavaScript的 作用域，提升，闭包等概念，希望你能有所收获，这也是我在读《你不知道的JavaScript·上卷》的一些体会。下一部分整理下 this解析、对象、原型 等一些概念。","categories":[],"tags":[{"name":"作用域","slug":"作用域","permalink":"http://iyue.top/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"闭包","slug":"闭包","permalink":"http://iyue.top/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"将本地代码关联到远程仓库","slug":"将本地代码关联到远程仓库","date":"2018-08-16T06:28:57.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/08/16/将本地代码关联到远程仓库/","link":"","permalink":"http://iyue.top/2018/08/16/%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E5%85%B3%E8%81%94%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"在项目的建立初期都是先搭建基础框架，在完成基础框架的搭建后，才把代码放到代码管理服务器上，让项目组成员进行检出从而进行需求的开发。而基础框架的搭建大部分都是先在个人的电脑上完成的，当完成框架搭建后，此时就要把代码共享到代码服务器上供开发人员检出。 准备工作本地安装git，在远程建有仓库，由于我们是将本地代码推到远程仓库，所以建远程仓库的时候不要进行初始化，即不必在仓库下添加任何文件，如readme.mdd等。 本地仓库初始化123git init // 初始化版本库git add . // 添加文件到版本库（只是添加到缓存区），.代表添加文件夹下所有文件 git commit -m &quot;first commit&quot; // 把添加的文件提交到版本库，并填写提交备注 关联推送123git remote add origin 你的远程库地址 // 把本地库与远程库关联git push -u origin master // 第一次推送时git push origin master // 第一次推送后，直接使用该命令即可推送修改 之后可能需要输入用户名密码，或者是ssh的形式。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://iyue.top/tags/git/"}]},{"title":"vue中引入图片的方式","slug":"vue中引入图片的方式","date":"2018-08-16T06:11:14.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/08/16/vue中引入图片的方式/","link":"","permalink":"http://iyue.top/2018/08/16/vue%E4%B8%AD%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"template和css中在 template 的 img 标签等和 css 的背景图中 1&lt;img class=&quot;logo-img&quot; src=&quot;~@/assets/logo/logo.png&quot; key=&quot;max-logo&quot; /&gt; 1background: url(~@/assets/dongdong.png) 4px 4px no-repeat; 其中‘~’为的是让 webpack 识别这是一个路径，‘@’表示 webpack 中配置的路径别名，此处表示 src 文件夹 在js中在 js 中作为变量引入时，需要以 require 的方式引入 123default_avatar() &#123; return require(&#x27;@/assets/avatar/avatar_&#x27; + this.name.length % 10 + &#x27;.png&#x27;)&#125; 此处引入不需要前面写‘~’ assets与static的区别 静态文件（主要指图片）均放在了src文件夹下的assets下，此处考虑到引入的资源都是属于项目本身的文件；此处的文件会被webpack的插件处理，如压缩，base64，hash等； static中应放置公共的类库等，如jQuery；此处的文件会直接复制到输出文件夹dist下的static中，不会被webpack处理；引入时直接以绝对路径引入即可。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://iyue.top/tags/vue/"}]},{"title":"node在Windows下的安装与配置","slug":"node在Windows下的安装与配置","date":"2018-08-16T02:16:35.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/08/16/node在Windows下的安装与配置/","link":"","permalink":"http://iyue.top/2018/08/16/node%E5%9C%A8Windows%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"","text":"安装在Windows下安装node很简单，直接取官网下载安装包，一路next就可以了，最新的安装包包含了npm，也会默认把node运行文件所在的目录添加到环境变量中。 当在终端执行node -v命令时，输出相应版本号说明安装成功。 配置npm默认的模块缓存路径及全局安装路径都在C盘，习惯上我们自行指定一个位置，一般会把node安装在D盘，相应的路径也设置在node目录下 在nodejs的目录下提前创建好两个文件夹node_global和node_cache 如下命令设置路径： 12npm config set prefix &quot;D:\\\\nodejs\\\\node_global&quot;npm config set cache &quot;D:\\\\nodejs\\\\node_cache&quot; 设置完成后可通过npm config ls查看相关设置 此时需要将node_global路径加入到环境变量，这样保证终端可以找到全局安装的模块 注意有些教程里会指导将全局模块的路径直接设置在nodejs目录下 1npm config set prefix &quot;D:\\\\nodejs&quot; 全局安装的模块会安装在node_modules下，和默认安装的npm在一起，命令文件就在nodejs下，这样就不需要再添加环境变量了 但这种做法会带来一个问题就是，无法通过npm un npm@lstest -g来升级npm模块，因为npm无法再升级安装的时候覆盖自己，而正常的npm升级是在全局模块的路径安装最新的npm，所以按照开头的路径设置，在node在会有两个npm，一个是默认安装的，一个是升级的时候安装在全局路径的。 所以还是建议全局路径设置另外的文件路径，并添加至环境变量。","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://iyue.top/tags/node/"}]},{"title":"css中如何使用wwebpack路径别名","slug":"css中如何使用wwebpack路径别名","date":"2018-08-12T05:59:32.000Z","updated":"2022-01-09T08:17:42.025Z","comments":true,"path":"2018/08/12/css中如何使用wwebpack路径别名/","link":"","permalink":"http://iyue.top/2018/08/12/css%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8wwebpack%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D/","excerpt":"","text":"引言在用 Webpack 处理打包时，可将某一目录配置一个别名，代码中就能使用与别名的相对路径引用资源。在 Vue 项目中，我们通常使用 vue-webpack 脚手架生成工程模板，然后配置 @ 为项目根目录下放资源和源码的 /src 目录的别名。 123456resolve: &#123; ..., alias: &#123; &#x27;@&#x27;: resolve(&#x27;src&#x27;) &#125;&#125; 这样我们就可以在 js 中用导入模板文件或者js就可以用如下方式导入： 1import tool from &#x27;@/style/xxx&#x27; 但是在样式文件（css/less/scss等）中，使用 @import “@/style/theme” 的语法引用相对 @ 的目录确会报错，“找不到 ‘@’ 目录”，说明 webpack 没有正确识别资源相对路径。 分析原因是 css 文件会被用 css-loader 处理，这里 css @import 后的字符串会被 css-loader 视为绝对路径解析，因为我们并没有添加 css-loader 的 alias，所以会报找不到 @ 目录。 解决在 Webpack 中 css import 使用 alias 相对路径的解决办法有两种； 方法一-添加模块路径直接为 css-loader 添加 ailas 的路径，但是在 vue-webpack 给的模板中，单独针对这个插件添加配置就显得麻烦冗余了；方法是： 123456789// 添加配置modules: [ resolve(&#x27;src&#x27;), resolve(&#x27;node_modules&#x27;) ],alias: &#123; &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27;, &#x27;@&#x27;: resolve(&#x27;src&#x27;), &#125; 这样我们就可以在vue页面如下导入css文件 1@import &#x27;~assets/css/all.scss&#x27;; // assets是src目录下的文件夹 方法二-添加‘~’符号是在引用路径的字符串最前面添加上 ~ 符号，如下 1@import &#x27;~@/assets/css/all.scss&#x27;; // assets是src目录下的文件夹 Webpack 会将以 ~ 符号作为前缀的路径视作依赖模块而去解析，这样 @ 的 alias 配置就能生效了。 看起来还是方法二方便，不用配置webpack，直接使用。 总结~ 视为模块解析是 webpack 做的事，不是 css-loader 做的事。各类非 js 直接引用（import require）静态资源，依赖相对路径加载问题，都可以用 ~ 语法完美解决。 123css module 中： @import &quot;~@/style/theme&quot;css 属性中： background: url(&quot;~@/assets/xxx.jpg&quot;)html 标签中： &lt;img src=&quot;~@/assets/xxx.jpg&quot; alt=&quot;alias&quot;&gt;","categories":[{"name":"webpack","slug":"webpack","permalink":"http://iyue.top/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://iyue.top/tags/webpack/"}]}],"categories":[{"name":"webpack","slug":"webpack","permalink":"http://iyue.top/categories/webpack/"}],"tags":[{"name":"http","slug":"http","permalink":"http://iyue.top/tags/http/"},{"name":"django","slug":"django","permalink":"http://iyue.top/tags/django/"},{"name":"XSS","slug":"XSS","permalink":"http://iyue.top/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"http://iyue.top/tags/CSRF/"},{"name":"cookie","slug":"cookie","permalink":"http://iyue.top/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://iyue.top/tags/session/"},{"name":"跨域","slug":"跨域","permalink":"http://iyue.top/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"post","slug":"post","permalink":"http://iyue.top/tags/post/"},{"name":"值类型","slug":"值类型","permalink":"http://iyue.top/tags/%E5%80%BC%E7%B1%BB%E5%9E%8B/"},{"name":"作用域","slug":"作用域","permalink":"http://iyue.top/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"name":"闭包","slug":"闭包","permalink":"http://iyue.top/tags/%E9%97%AD%E5%8C%85/"},{"name":"git","slug":"git","permalink":"http://iyue.top/tags/git/"},{"name":"vue","slug":"vue","permalink":"http://iyue.top/tags/vue/"},{"name":"node","slug":"node","permalink":"http://iyue.top/tags/node/"},{"name":"webpack","slug":"webpack","permalink":"http://iyue.top/tags/webpack/"}]}
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"iyue.top","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="我是萌新">
<meta property="og:type" content="website">
<meta property="og:title" content="山外小楼">
<meta property="og:url" content="http://iyue.top/page/2/index.html">
<meta property="og:site_name" content="山外小楼">
<meta property="og:description" content="我是萌新">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="萌新">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://iyue.top/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>山外小楼</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">山外小楼</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">前端攻略</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">萌新</p>
  <div class="site-description" itemprop="description">我是萌新</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iyue.top/2018/09/13/%E7%BD%91%E5%9D%80%E6%9C%80%E5%90%8E%E7%9A%84%E6%96%9C%E6%9D%A0%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="萌新">
      <meta itemprop="description" content="我是萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山外小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/13/%E7%BD%91%E5%9D%80%E6%9C%80%E5%90%8E%E7%9A%84%E6%96%9C%E6%9D%A0%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">网址最后的斜杠问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-13 20:44:13" itemprop="dateCreated datePublished" datetime="2018-09-13T20:44:13+08:00">2018-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 16:17:42" itemprop="dateModified" datetime="2022-01-09T16:17:42+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>许多网站的访问在网址后面有时会带一个‘/’，有时没有，但经常带不带都访问的都是同一个网页；最近在用django的时候发现这个问题；现记录下来。</p>
<h2 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h2><p>在django的框架下，访问路由地址的时候，如果你的路由地址配置为如下这种</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^user/$&#x27;</span>, <span class="string">&#x27;get_user_info&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>框架默认会将不带斜杠的路由重定向到带斜杠的路由下，这是访问<code>***.com/user</code>和<code>***.com/user/</code>都可以；</p>
<p>如果配置为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^user$&#x27;</span>, <span class="string">&#x27;get_user_info&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这在访问<code>***.com/user</code>时没有问题，访问<code>***.com/user/</code>时就会报404错误。</p>
<blockquote>
<p>注意的是，这种重定向会被浏览器记住，当你改变配置为不带斜杠的时候，继续访问浏览器会被重定向到带斜杠的地址，而发生404错误；</p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>django的配置文件settings.py中，默认的设置(该配置未显式写出)为Ture;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND_SLASH = <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>指示不带斜杠的情况下会重定向到带斜杠的地址；如果设置为False,就不会重定向；</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iyue.top/2018/09/07/XXS%E4%B8%8ECSRF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="萌新">
      <meta itemprop="description" content="我是萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山外小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/07/XXS%E4%B8%8ECSRF/" class="post-title-link" itemprop="url">XSS与CSRF</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-07 20:18:20" itemprop="dateCreated datePublished" datetime="2018-09-07T20:18:20+08:00">2018-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 16:17:42" itemprop="dateModified" datetime="2022-01-09T16:17:42+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>针对前端安全，主要有XSS跨站脚本攻击，CSRF跨站伪造请求，SQL注入等，今天主要讨论下关于前两种</p>
<h2 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h2><p>更多具体详细的解释可以查看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aware-why/p/5845202.html">XSS（跨站脚本攻击）的最全总结</a></p>
<p>XSS攻击通常被分为两类：存储型和反射型。还有第三类，和基于DOM的xss；下面我们不说定义直接看看怎么操作</p>
<ol>
<li>反射型</li>
</ol>
<p>一般有搜索框的网站，在搜索东西的时候会在结果页呈现你搜索的字符；</p>
<p>比如你搜索<code>笔记本电脑</code>，网站会提示<code>你搜索“笔记本电脑”的结果如下</code>，这说明用户的输入在页面上有了呈现；那么我们输入一段恶意脚本，也许也会原样输出执行，比如我们输入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="number">1</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>恶意代码就是你可以放一段脚本，比较加入一个js文件请求，在js代码里来获取cookie等用户信息，并发送给自己；但用户并不会自己输入恶意脚本，那么就通过邮件等方式，让用户点击搜索结果连接，以达到脚本注入的目的；</p>
<p>当然基本上没什么网站会有这么明显的漏洞，这里只是演示说如何实现反射型攻击。</p>
<ol start="2">
<li>存储型</li>
</ol>
<p>这种一般常出现在用户可输入，然后在网站动态展示，大家都能看到的网站，如微博，社区，评论等地方；常见的做法就是发一段脚本到输入区，网站会记录下来并动态的渲染在页面上，只要访问的用户都能看到；由于这种情形注入的脚本被写到了服务器数据库中，所以叫存储型攻击；</p>
<ol start="3">
<li>基于DOM</li>
</ol>
<p>这种攻击的前提是易受攻击的网站有一个HTML页面采用不安全的方式从document.location 或document.URL 或 document.referrer获取数据（或者任何其他攻击者可以修改的对象），也就是说恶意代码直接来自这些可任意被修改的对象；详细可查看<a target="_blank" rel="noopener" href="https://www.oschina.net/translate/dom-based-xss-of-third-kind">基于 DOM 的第三类跨站脚本 XSS</a></p>
<p>如上，一般只要这个网站某个页面将用户的输入包含在它生成的动态输出页面中并且未经验证或编码转义，这个缺陷就存在。</p>
<ol start="4">
<li><p>防范方法</p>
<ol>
<li>所有前端的页面渲染，尽量使用ajax异步进行，从后台获取要显示的数据。</li>
<li>前端提交过来的数据，在后台入口处统统对HTML中的关键字进行html编码转义。</li>
</ol>
</li>
</ol>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>更多具体详细的解释可以查看<a target="_blank" rel="noopener" href="http://www.vuln.cn/7134">邪恶的CSRF – superfish</a></p>
<p>CSRF叫跨域伪造请求，其实就是模拟用户操作，就是在A网站登录的情况下，B网站可以发起A网站发起的请求；要达成这个目的就需要解决跨域的问题；  </p>
<p>传统的ajax都有跨域的限制，但如发起get请求就很方便，以打开url的方式，jsonp的方式，请求三方资源的方式，都可以达成目的；</p>
<p>而采用原生表单的提交方式，可以发起post跨域请求；</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iyue.top/2018/09/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="萌新">
      <meta itemprop="description" content="我是萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山外小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">单点登录的实现方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-06 21:02:01" itemprop="dateCreated datePublished" datetime="2018-09-06T21:02:01+08:00">2018-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 16:17:42" itemprop="dateModified" datetime="2022-01-09T16:17:42+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>该篇文章很多段落来自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ywlaker/p/6113927.html">单点登录原理与简单实现</a>，大家可以先拜读这篇文章，这篇文章讲述十分详细，我这里只是插了一些自己的疑虑，而且可能还说的不是很清楚，权当自己做个笔记了</p>
<h2 id="单系统登录机制"><a href="#单系统登录机制" class="headerlink" title="单系统登录机制"></a>单系统登录机制</h2><ol>
<li>http无状态协议</li>
</ol>
<p>http作为通信协议，是无状态的，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联。  </p>
<p>但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。</p>
<ol start="2">
<li>会话机制</li>
</ol>
<p>浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了。  </p>
<blockquote>
<p>这里有个session和cookie的区别；其实session算是cookie的变种；因为本身的机制形式并没有变，依然是需要浏览器有一个信息串和服务器得会话对象所对应，只不过早先得cookie是在浏览器端保存得用户的信息，服务器通过这些信息来识别用户，而session方式是把信息保存在了服务器端，然后生成一个session的id字符串存在了cookie，相对之前的做法安全一些；但本质未发生变化。</p>
</blockquote>
<blockquote>
<p>当然，浏览器但端的信息其实不是必须存在cookie里，也可以放在localstotage或者其他可存的地方，这样防止从cookie得到敏感信息，但这样就需要前端做一个手工处理，将这个id发送给服务器端；目前大多的系统还是主要以cookie来存储的，一是读写cookie浏览器可以自动完成，二是在单点登录系统时可以帮其他子应用自动登录。</p>
</blockquote>
<ol start="3">
<li>登录状态</li>
</ol>
<p>有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态。</p>
<blockquote>
<p>个人理解，http是无状态的，那么每个受限请求都是需要验证的，那么前端传来的id只要可以对应后端的session，那么就是合法的，所以不太清楚后端是否还要做一个会话标记的操作；</p>
</blockquote>
<h2 id="多系统的复杂性"><a href="#多系统的复杂性" class="headerlink" title="多系统的复杂性"></a>多系统的复杂性</h2><p>web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。</p>
<p>单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie。也就是说A应用登录后，打开B应用，B是拿不到A的cookie的。</p>
<p>这时我们就将web应用群中所有子系统的域名统一在一个顶级域名下，在顶级域名下设置的cookie，其子域名是可以访问其cookie的。  </p>
<blockquote>
<p>这里有个cookie设置的规则（有点儿像全局作用域和子作用域）：<br>设置cookie只可以向上设置，可设置本级域名，或者向上的域名；比如顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名等等，否则cookie无法生成；二级域名可以设置本域及顶级域；<br>获取cookie只可以向上获取，可获取本级域名，或者向上的域名；比如顶级域名只能获取到domain设置为顶级域名的cookie，domain设置为其他子级域名的无法获取；二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。<br>总的来说，顶级域名设置的cookie可以共享【需要指定domain主域名的host】给二级域名，也可以自己私有【不指定domain】</p>
</blockquote>
<ul>
<li>这里云平台系统采用的就是这种方式，sessionid由统一认证系统生成，并写到顶级域名下面，其余子系统通过访问cookie获取该id与统一认证系统进行权限验证；不过这里是子系统通过统一认证系统生成的token然后在服务端去统一认证系统换取sessionid，由子系统写到cookie里的顶级域名下的，不太清楚这一步是什么意思；这样，各个子系统的共享统一生成的sessionid，并且每个受限请求都去找认证系统授权；这种方式也很方便的可以做到统一登出，只要使统一认证系统的session失效就可以了。</li>
</ul>
<p>然而，可行并不代表好，共享cookie的方式存在众多局限。首先，应用群域名得统一；其次，应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间；第三，cookie本身不安全。</p>
<p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</p>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>这里说的单点登录，是指有一个统一认证中心，可实现一处登录，全都登录，一处登出，全部登出，并且不局限与同一个顶级域名下。</p>
<p>单点登录的简单流程如下图：</p>
<p><img src="/img/sso_001.png" alt="单点登录流程"></p>
<p><img src="/img/sso_002.png" alt="单点登出流程"></p>
<p>其中有两个主要注意的地方，就是在认证中心登录的时候，会帮其他子系统都登录，登出的时候会帮其他子系统都登出；另外子系统的sessionid是各自维护还是统一有认证系统维护；</p>
<ol>
<li>统一登录登出机制</li>
</ol>
<p>在统一认证中心登录后，可以以跨域访问的形式，将统一的生成的token，逐个发送给各个子系统，子系统收到后向认证中心认证token，认证通过后可以给自己系统下写入cookie，这样，在访问其他子系统的时候，请求会带上之前写的cookie，从而打开子系统即为登录状态；</p>
<p>在子系统登出时会跳转到登录页面，此时可以以跨域访问的形式，逐个访问各个子系统请求，这些请求会携带各自域名下的sessionid，子系统就会注销该id，完成各个子系统的登出；</p>
<ol start="2">
<li>sessinid维护方式</li>
</ol>
<p>如果各自维护sessionid，登录的时候不通知子系统的话，打开其他子系统的时候会有一个重定向到认证中心获取状态的过程；通知了的话就无需重定向了；在登出的时候认证中心必须去通知各个子系统登出，不然子系统无法知道已登出；</p>
<p>如果认证系统统一维护sessionid的话，登录不通知也会去重定向；登出就不必通知了。</p>
<ul>
<li>如金融的sso认证系统便没有去通知其他子系统登录状态，在访问子系统的时候会重定向到认证地址，认证地址根据cookie信息，确认已登录后，将token带在请求上，重定向回子系统，子系统拿到token后去认证中心通过后再写sessionid，这样会有一个重定向url变更的过程；而登出的时候，由于并未通知其他子系统，所以登出无法做到统一登出；不过，此处既然没有做统一登出，那么在登录的时候也不应该去通知子系统去登录；这样这个系统其实算是个统一认证中心，不算严格意义的单点登录。</li>
</ul>
<ol start="3">
<li>通知其他子系统登录登出的形式</li>
</ol>
<p>由于域名不同，通知其他子系统只能以跨域的形式去访问各自的服务器；可以以jsonp的形式,也可以是cors的形式，或者其他跨域方式，但需要将统一认证生成的token信息手动加到请求中，因为跨域请求不会携带本域的cookie信息。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iyue.top/2018/09/06/django%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%AE%BE%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="萌新">
      <meta itemprop="description" content="我是萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山外小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/06/django%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%AE%BE%E7%BD%AE/" class="post-title-link" itemprop="url">django的跨域请求设置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-06 11:26:30" itemprop="dateCreated datePublished" datetime="2018-09-06T11:26:30+08:00">2018-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 16:17:42" itemprop="dateModified" datetime="2022-01-09T16:17:42+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h2><p>由于django本身的权限管理是基于cookie来认证的，而整个过程并不需要前端做什么，直接后端完成；但跨域的时候，产生几个问题；</p>
<ol>
<li>django如何跨域？</li>
<li>django跨域后可以正常的写入cookie吗？</li>
</ol>
<p>其实，跨域实现的方法有很多种，可以查看<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案（全）</a>，在此我们使用cors跨域的方式</p>
<h2 id="cors跨域概述"><a href="#cors跨域概述" class="headerlink" title="cors跨域概述"></a>cors跨域概述</h2><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）  </p>
<p>相关内容可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/keyi/p/6726089.html">跨域CORS原理及调用具体示例</a></p>
<blockquote>
<p>引起我们注意的一点就是同为post请求，当<code>Content-Type</code>的值为<code>application/json</code>时，就变成了非简单请求，基础表现就是浏览器会先发一个”预检”请求</p>
</blockquote>
<h2 id="django跨域设置"><a href="#django跨域设置" class="headerlink" title="django跨域设置"></a>django跨域设置</h2><ol>
<li>执行安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/ottoyiu/django-cors-headers/</span></span><br><span class="line">pip install django-cors-headers</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置settings.py</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;corsheaders&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">MIDDLEWARE = [  <span class="comment"># Or MIDDLEWARE_CLASSES on Django &lt; 1.10</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">...</span><br><span class="line"><span class="comment"># cookies will be allowed to be included in cross-site HTTP requests</span></span><br><span class="line">CORS_ALLOW_CREDENTIALS = <span class="literal">True</span> </span><br><span class="line"><span class="comment"># If True, the whitelist will not be used and all origins will be accepted</span></span><br><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">False</span></span><br><span class="line"><span class="comment"># A list of origin hostnames that are authorized to make cross-site HTTP requests</span></span><br><span class="line">CORS_ORIGIN_WHITELIST = (</span><br><span class="line">    <span class="string">&#x27;localhost:8888&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="显式设置cookie"><a href="#显式设置cookie" class="headerlink" title="显式设置cookie"></a>显式设置cookie</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># view.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;code&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;this is a test&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        rep = HttpResponse(json.dumps(data, cls=CJsonEncoder), content_type=<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        rep.set_cookie(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> rep</span><br></pre></td></tr></table></figure>

<h2 id="前端设置"><a href="#前端设置" class="headerlink" title="前端设置"></a>前端设置</h2><p>前端默认不允许跨域携带cookies，需进行显式的设置；不同的库可能有一些细微的差别；</p>
<blockquote>
<p>需要注意的是，以原生表单的形式，发起post请求，是可以携带cookie自动跨域的，无需其他设置；form表单可以跨域一个是历史原因要保持兼容性，一个是form表单会刷新页面不会把结果返回给js，所以相对安全，但其实请求已经发送出去了，你只是拿不到响应而已；这个问题会引起CSRF攻击；</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生js（亲测可用，其余未作测试）</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();  </span><br><span class="line">xhr.open(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://localhost:8000/api/test/&quot;</span>, <span class="literal">true</span>);  </span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>; <span class="comment">//支持跨域发送cookies</span></span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;http://localhost:8000/api/test/&quot;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">    <span class="attr">xhrFields</span>: &#123;<span class="attr">withCredentials</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    <span class="attr">crossDomain</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// axios（vue常用的方案）</span></span><br><span class="line">axios.create(&#123;</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span> <span class="comment">// 允许携带cookie</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="突然来的疑问"><a href="#突然来的疑问" class="headerlink" title="突然来的疑问"></a>突然来的疑问</h2><p>写到此时，我所作的测试都是在本地测的，服务器端在localhost:8000,前端在localhost:8888;而跨域操作所写的cookie均在localhost之下，这样就有一个问题，跨域读写的cookie到底是哪里？是发起请求页的域还是请求地址的域？</p>
<h2 id="解答疑问"><a href="#解答疑问" class="headerlink" title="解答疑问"></a>解答疑问</h2><p>我们得到的答案是cors跨域读写的cookie都是请求地址的cookie；比如我们请求第三方cdn，并不会携带本站的cookie，发送跨域请求也一样，只会携带请求指向地址的域的cookie。（这也是跨站伪造请求csrf的原理）  </p>
<blockquote>
<p>服务器如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>
</blockquote>
<p>如果非要跨域写cookie呢？有什么办法吗？</p>
<h2 id="跨域写本域cookie"><a href="#跨域写本域cookie" class="headerlink" title="跨域写本域cookie"></a>跨域写本域cookie</h2><p>查到的方法如下：<br>可以通过ngix反向代理跨域配置：proxy_cookie_domain b.com a.com;<br>也可以通过中间件http-proxy-middleware代理跨域时，配置加上cookieDomainRewrite: ‘a.com’参数，都是用来修改转发过来的cookie中域名为当前a.com域，所以实现了a.com下cookie写入。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iyue.top/2018/09/05/post%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="萌新">
      <meta itemprop="description" content="我是萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山外小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/05/post%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">post请求的提交数据的几种方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-05 20:00:13" itemprop="dateCreated datePublished" datetime="2018-09-05T20:00:13+08:00">2018-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 16:17:42" itemprop="dateModified" datetime="2022-01-09T16:17:42+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。<br>我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。<br>协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。<br>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。</p>
<blockquote>
<p>个人理解：get请求其实就是将参数以key=value&amp;key=value的形式拼在url发往服务器，所以get请求没有那么多复杂的说法；而post请求规定提交的数据必须放在消息主体（entity-body）中，但没有对形式的规定，所以就有了各种各样的方式；</p>
</blockquote>
<h2 id="引出问题"><a href="#引出问题" class="headerlink" title="引出问题"></a>引出问题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> data1 = <span class="string">&#x27;&#123;&quot;arr&quot;:[1,2,3,4,5],&quot;test&quot;:&quot;name&quot;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> data2 = <span class="string">&#x27;name=jack&amp;age=998&#x27;</span></span><br><span class="line"><span class="comment">// 使用post请求</span></span><br><span class="line">ajax.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;http://localhost:8000/api/test/&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 使用post发送数据 必须 设置 如下内容</span></span><br><span class="line"><span class="comment">// 修改了 发送给 服务器的 请求报文的 内容</span></span><br><span class="line"><span class="comment">// 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。</span></span><br><span class="line"><span class="comment">// 然后在 send() 方法中规定您希望发送的数据：</span></span><br><span class="line">ajax.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line"><span class="comment">// post请求 发送的数据 写在 send方法中</span></span><br><span class="line"><span class="comment">// 格式 name=jack&amp;age=18 字符串的格式;</span></span><br><span class="line"><span class="comment">// 不能直接发送一个对象，否则后端会变成[object Object]</span></span><br><span class="line">ajax.send(data2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">ajax.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ajax.readyState == <span class="number">4</span> &amp;&amp; ajax.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ajax.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>ajax.send()</code>的内容可以是data1的格式（<code>JSON.stringfy()</code>得来），也可以是data2的格式（<code>qs.stringfy()</code>得来），两种的方式都可以；  </p>
<blockquote>
<p>另外ajax.send()不能直接发送对象，后端接受会变成[object Object]，而对于axios库，直接发送对象，它会自动转成json字符串；</p>
</blockquote>
<p>在后端为django的代码中测试  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> request.POST.get(<span class="string">&#x27;arr&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span> request.body</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;code&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;this is a test&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> HttpResponse(json.dumps(data, cls=CJsonEncoder), content_type=<span class="string">&quot;application/json&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如何是data1的格式就是json字符串的话，<code>request.POST</code>是无法获取到东西的，data2格式通过<code>request.POST</code>是可以获取到的，但前提是请求的<code>Content-type</code>必须设置为<code>application/x-www-form-urlencoded</code>,否则都获取不到结果，只能从request.body中获得原始数据；<br>之所以这样是因为django框架在处理响应时，只对<code>Content-type</code>为<code>application/x-www-form-urlencoded</code>的情况做了处理，（具体可以查看django的源码中<code>class HttpRequest(object)</code>对post的处理部分）<br>django之所以这么做，是因为什么呢？下面先说一下关于post的几种请求方式</p>
<h2 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h2><p>这是post的默认请求方式，在post请求不设置<code>Content-type</code>时的默认值；  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8000/api/test/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mickey&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span> Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mouse&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这也是原始提交表单的方式，在表单提交的方式里，浏览器会把表单里的数据，以<code>key=value&amp;key=value</code>的形式发送给服务器；个人理解，由于这种最初的提交方式,决定了<code>application/x-www-form-urlencoded</code>下对数据的处理;<br>所以，在ajax请求的年代，其实传哪种（data1和data2）格式都可以，不同的是，服务器是以<code>Content-type</code>的类型来决定如何处理数据的；  </p>
<blockquote>
<p>这种post的类型的时候可以向服务器发送数据，而数据的格式应为键值对<code>key=value&amp;key=value</code>，js对象可以通过<code>qs.stringfy()</code>来序列化得到;不过，qs在序列化数组的时候默认会序列化为<code>arr[]=value&amp;arr[]=value</code>的形式；这时需要配置下qs，指定数组的编码格式；否则后端获取不到该数组；  </p>
</blockquote>
<blockquote>
<p>django接收数组的时候用<code>request.POST.getlist()</code>;如果前端序列化带了<code>[]</code>，后端也需要带，或者要前端序列化的时候去掉<code>[]</code>；</p>
</blockquote>
<p>指定数组的编码格式和对应的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> params = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// indices(默认)</span></span><br><span class="line">qs.stringify(&#123;<span class="attr">a</span>: params&#125;, &#123;</span><br><span class="line">    <span class="attr">arrayFormat</span>: <span class="string">&#x27;indices&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果是</span></span><br><span class="line"><span class="string">&#x27;a[0]=1&amp;a[1]=2&amp;a[2]=3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// brackets </span></span><br><span class="line">qs.stringify(&#123;<span class="attr">a</span>: params&#125;, &#123;</span><br><span class="line">    <span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果是</span></span><br><span class="line"><span class="string">&#x27;a[]=1&amp;a[]=2&amp;a[]=3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// repeat</span></span><br><span class="line">qs.stringify(&#123;<span class="attr">a</span>: params&#125;, &#123;</span><br><span class="line">    <span class="attr">arrayFormat</span>: <span class="string">&#x27;repeat&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 结果是</span></span><br><span class="line"><span class="string">&#x27;a=1&amp;a=2&amp;a=3&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a>application/json</h2><p>这种方式就是告诉服务器，传输的数据为json字符串，所以对应的数格式应为json字符串，js对象可以通过<code>JSON.stringfy()</code>来序列化得到；这是一种略新的格式，可能早期的ie等浏览器不支持 </p>
<blockquote>
<p>如果发送对象比较复杂比如<code>[&#123;&quot;id&quot;:&quot;001&quot;,&quot;name&quot;:&quot;小明&quot;&#125;,&#123;&quot;id&quot;:&quot;002&quot;,&quot;name&quot;:&quot;小军&quot;&#125;]</code>；这时候还是简单的用json字符串为好，表单提交的方式可能会造成后端解析困难的情况，另外也很难看懂结果;</p>
</blockquote>
<h2 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h2><p>这种类型主要用来上传文件（可上传多个），也可以发送键值对；（该内容后续展开）</p>
<h2 id="text-plain-text-json-xml-html"><a href="#text-plain-text-json-xml-html" class="headerlink" title="text/plain (text/json/xml/html)"></a>text/plain (text/json/xml/html)</h2><p>数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符。postman软件里标的是RAW,<code>application/json</code>包含在RAW里；</p>
<h2 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h2><p>暂没用过，只在postman中看到过，相当于<code>Content-Type:application/octet-stream</code>,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iyue.top/2018/08/24/js%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E6%94%BE%E8%A7%A3%E6%83%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="萌新">
      <meta itemprop="description" content="我是萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山外小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/24/js%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%AD%98%E6%94%BE%E8%A7%A3%E6%83%91/" class="post-title-link" itemprop="url">js变量在内存的存放解惑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-24 19:56:56" itemprop="dateCreated datePublished" datetime="2018-08-24T19:56:56+08:00">2018-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 16:17:42" itemprop="dateModified" datetime="2022-01-09T16:17:42+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="js变量的类型"><a href="#js变量的类型" class="headerlink" title="js变量的类型"></a>js变量的类型</h2><p>我们知道js变量有两种类型</p>
<ul>
<li>基本类型值，指简单的数据段，对于undefined、null、boolean、number、string这5种简单数据类型可以直接操作保存在变量中的实际值，也就是按值访问。</li>
<li>引用类型值，指那些可能由多个值构成的对象，只能操作对象的引用而不是实际的对象，所以要得到引用类型这种值只能按引用访问。</li>
</ul>
<h2 id="变量的存放方式"><a href="#变量的存放方式" class="headerlink" title="变量的存放方式"></a>变量的存放方式</h2><p>有如下代码段（赋值基本类型）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码定义了两个变量，定义<code>a=1</code>在栈内存开辟一块空间存放<code>1</code>这个值，同理定义<code>b=1</code>也开辟一块内存存放<code>1</code>这个值；<br>当修改变量的值的时候，比如重新赋值<code>a=3</code>，那么就会重新开辟一块内存，将<code>3</code>存入后，把<code>a</code>指向<code>3</code>所在的内存位置；</p>
<blockquote>
<p>有个问题还没考证，就是不同的变量定义的值一样的时候，是不是指向的是同一块内存。在python中可以通过id来访问存放位置的id，在值（基本类型）较小的时候，就是指向同一块内存</p>
</blockquote>
<p>有如下代码段（赋值引用类型）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c=&#123;<span class="attr">name</span>:<span class="string">&#x27;阿Q&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> d=&#123;<span class="attr">name</span>:<span class="string">&#x27;阿Q&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码定义了两个变量，定义<code>c</code>的时候在栈内存开辟一块空间存放一个内存地址，这个内存地址指向堆内存中放<code>&#123;name:&#39;阿Q&#39;&#125;</code>这个对象的内存；<code>d</code>同样如此，而且两个对象是毫无关系的，他们的内存地址是不一样的。<br>当修改变量的值的时候，如<code>c=&#123;name:&#39;老王&#39;&#125;</code>，这种情况就和基本类型一样，属于重新赋值，就会将对象<code>&#123;name:&#39;老王&#39;&#125;</code>存到堆内存中，将对象的地址存到栈内存中，c指向这个内存；<br>当修改变量，如<code>c.name=&#39;老张&#39;</code>，这种情况可以看作给对象做一个修正或者扩展，不属于重新赋值，虽然结果是修改了对象，但并没有改动对象所在的位置，即<code>c</code>指向的栈内存里存放的对象的地址并没有变；<br>当然如果如下定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c=d=&#123;<span class="attr">name</span>:<span class="string">&#x27;阿Q&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> a=b=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这样的连等赋值，有另外的说法，之后专写一篇关于连等赋值的问题。  </p>
<h2 id="函数传参是按值传递还是引用传递"><a href="#函数传参是按值传递还是引用传递" class="headerlink" title="函数传参是按值传递还是引用传递"></a>函数传参是按值传递还是引用传递</h2><p>对于这块内容，网上很多博文说法很多，还有说共享传递啥的，在此我们不对这些字面进行讨论，我们就解释下本质到底是怎么个情况。<br>比如有如下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(a);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 仍为1, 未受x = 2赋值所影响</span></span><br></pre></td></tr></table></figure>
<p>这个就无需多解释了，x作为一个形参，只在函数内部生效，而且当a当作参数传给x的时候，其实就是复制了一份a指向的栈内存中存放的值，所以a和x就是毫无关系了<br>如果a为一个引用类型，如下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o.x = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.x); <span class="comment">// 3, 被修改了!</span></span><br></pre></td></tr></table></figure>
<p>此处也一样，x作为一个形参，当obj当作参数传给o的时候，其实是复制了一份obj指向的栈内存中存放的对象的地址，所以obj和o在栈内存中是不一样的，但在栈内存中存的东西是一样的，就是对象<code>&#123;x : 1&#125;</code>所在的地址；<br>所以当修改o的时候，自然obj也就被修改了<br>还有人提出以下代码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">name</span>:<span class="string">&#x27;foo&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">   o = &#123;<span class="attr">name</span>:<span class="string">&#x27;bar&#x27;</span>&#125;;  </span><br><span class="line">&#125;</span><br><span class="line">test(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo.name); <span class="comment">// foo，未被修改；</span></span><br></pre></td></tr></table></figure>
<p>这个结果是没问题的，但这就是上文提到的对对象的修改的方式的问题，是直接赋值去修改变量，还是去修改对象的属性；<br>上述代码foo当作参数传给o，同样将对象所在地址赋值一份给了形参o，但函数中o的赋值操作，使形参o完全指向了另外一个对象的内存地址，这个操作，并不影响实参foo在内存中存放的地址，及地址所指向的对象；  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34377264/article/details/72782668">JS中函数的参数是按值传递还是按引用传递</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010953733">JavaScript参数按值传递的理解</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mcray/p/7002089.html">JS进阶系列之内存空间</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iyue.top/2018/08/22/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="萌新">
      <meta itemprop="description" content="我是萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山外小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/22/js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="post-title-link" itemprop="url">你不知道的JavaScript-第一部分</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-22 20:08:24" itemprop="dateCreated datePublished" datetime="2018-08-22T20:08:24+08:00">2018-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 16:17:42" itemprop="dateModified" datetime="2022-01-09T16:17:42+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文转自<a target="_blank" rel="noopener" href="https://github.com/ZengTianShengZ/My-Blog">ZengTianShengZ</a>，您可以直接去原处阅览</p>
</blockquote>
<h3 id="第一章：-作用域是什么"><a href="#第一章：-作用域是什么" class="headerlink" title="第一章： 作用域是什么"></a>第一章： 作用域是什么</h3><h4 id="1、-编译原理"><a href="#1、-编译原理" class="headerlink" title="1、 编译原理"></a>1、 编译原理</h4><p>JavaScript 被列为 ‘动态’ 或 ‘解释执行’ 语言，于其他传统语言（如 java）不同的是，JavaScript是边编译边执行的。<br>一段源码在执行前会经历三个步骤： <code>分词/词法分析</code> -&gt; <code>解析/语法分析</code> -&gt; <code>代码生成</code></p>
<ul>
<li>分词/词法分析</li>
</ul>
<p>  这个过程将字符串分解成词法单元，如 var a = 2; 会被分解成词法单元 var、 a、 = 、2、;。空格一般没意义会被忽略</p>
<ul>
<li>解析/语法分析</li>
</ul>
<p>  这个过程会将词法单元转换成 <code>抽象语法树</code>（Abstract Syntax Tree,AST）。<br>  如  var a = 2; 对应的 <code>抽象语法树</code> 如下, 可通过 <a target="_blank" rel="noopener" href="https://astexplorer.net/">在线可视化AST</a> 网址在线分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">  &quot;start&quot;: 0,</span><br><span class="line">  &quot;end&quot;: 10,</span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;VariableDeclaration&quot;,</span><br><span class="line">      &quot;start&quot;: 0,</span><br><span class="line">      &quot;end&quot;: 10,</span><br><span class="line">      &quot;declarations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;type&quot;: &quot;VariableDeclarator&quot;,</span><br><span class="line">          &quot;start&quot;: 4,</span><br><span class="line">          &quot;end&quot;: 9,</span><br><span class="line">          &quot;id&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">            &quot;start&quot;: 4,</span><br><span class="line">            &quot;end&quot;: 5,</span><br><span class="line">            &quot;name&quot;: &quot;a&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;init&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">            &quot;start&quot;: 8,</span><br><span class="line">            &quot;end&quot;: 9,</span><br><span class="line">            &quot;value&quot;: 2,</span><br><span class="line">            &quot;raw&quot;: &quot;2&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;kind&quot;: &quot;var&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码生成</li>
</ul>
<p>  将 AST 转换成可执行的代码，存放于内存中，并分配内存和转化为一些机器指令</p>
<h4 id="2、理解作用域"><a href="#2、理解作用域" class="headerlink" title="2、理解作用域"></a>2、理解作用域</h4><p>其实结合上面提到的编译原理，作用域就好理解了。作用域就是当前执行代码对这些标识符的访问权限。<br>编译器会在当前作用域中声明一些变量，运行时引擎会去作用域中查找这些变量（其实就是一个寻址的过程），如果找到这些变量就可以操作变量，找不到就往上一层作用域找（作用域链的概念），或者返回 null</p>
<h3 id="第三章：-函数作用域和块作用域"><a href="#第三章：-函数作用域和块作用域" class="headerlink" title="第三章： 函数作用域和块作用域"></a>第三章： 函数作用域和块作用域</h3><h4 id="1、函数中的作用域"><a href="#1、函数中的作用域" class="headerlink" title="1、函数中的作用域"></a>1、函数中的作用域</h4><p>每声明一个函数都会形成一个作用域，那作用域有什么用呢，它能让该作用域内的变量和函数不被外界访问到，也可以反过来说是不让该作用域内的变量或函数污染全局。</p>
<p>对比：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 123</span><br><span class="line">function bar() &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var a = 123</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量 a 和函数 bar 用一个函数 foo 包裹起来，函数 foo 会形成一个作用域，变量 a 和函数 bar 外界将无法访问，同时变量或函数也不会污染全局。</p>
<h4 id="2、函数作用域"><a href="#2、函数作用域" class="headerlink" title="2、函数作用域"></a>2、函数作用域</h4><p>进一步思考，上面例子的变量 a 和函数 bar 有了作用域，但函数 foo 不也是暴露在全局，也对全局造成污染了啊。是的，JavaScript对这种情况提出了解决方案： <code>立即执行函数 (IIFE)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function foo() &#123;</span><br><span class="line">  var a = 123</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>第一个（）将函数变成表达式，第二个（）执行了这个函数，最终函数 foo 也形成了自己的作用域，不会污染到全局，同时也不被全局访问的到。</p>
<h4 id="3、块作用域"><a href="#3、块作用域" class="headerlink" title="3、块作用域"></a>3、块作用域</h4><p>es6之前JavaScript是没有块作用域这个概念的，这与一般的语言（如Java ，C）很大不同，看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  console.log(&#x27;i=&#x27;, i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;输出&#x27;, i); // 输出 10</span><br></pre></td></tr></table></figure>
<p>for 循环定义了变量 i，通常我们只想这个变量 i 在循环内使用，但忽略了 i 其实是作用在外部作用域(函数或全局)的。所以循环过后也能正常打印出 i ,因为没有块的概念。</p>
<p>甚至连 try/catch 也没形成块作用域:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    console.log(&#x27;i=&#x27;, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (error) &#123;&#125;</span><br><span class="line">console.log(&#x27;输出&#x27;, i); // 输出 10</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决方法1</p>
</blockquote>
<p>形成块作用域的方法当然是使用 es6 的 let 和 const 了， let 为其声明的变量隐式的劫持了所在的块作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  console.log(&#x27;i=&#x27;, i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;输出&#x27;, i); // ReferenceError: i is not defined</span><br></pre></td></tr></table></figure>
<p>将上面例子的 var 换成 let 最后输出就报错了 ReferenceError: i is not defined ，说明被 let 声明的 i 只作用在了 for 这个块中。</p>
<p>除了 let 会让 for、if、try/catch 等形成块，JavaScript 的 <code>&#123;&#125;</code> 也能形成块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let name = &#x27;曾田生&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(name); //ReferenceError: name is not defined</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决方法2</p>
</blockquote>
<p>早在没 es6 的 let 声明之前，常用的做法是利用 <code>函数也能形成作用域</code> 这么个概念来解决一些问题的。</p>
<p>看个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var result = []</span><br><span class="line">  for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    result[i] = function () &#123;</span><br><span class="line">      return i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(i）// i 作用在整个函数，for 执行完此时 i 已经等于 10 了</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">var result = foo()</span><br><span class="line">console.log(result[0]()); // 输出 10 期望 0</span><br><span class="line">console.log(result[1]()); // 输出 10 期望 1</span><br><span class="line">console.log(result[2]()); // 输出 10 期望 2</span><br></pre></td></tr></table></figure>

<p>这个例子出现的问题是执行数组函数最终都输出了 10， 因为 i 作用在整个函数，for 执行完此时 i 已经等于 10 了, 所以当后续执行函数 <code>result[x]()</code> 内部返回的 i 已经是 10 了。</p>
<p>利用函数的作用域来解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var result = []</span><br><span class="line">  for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    result[i] = function (num) &#123;</span><br><span class="line">      return function () &#123; // 函数形成一个作用域，内部变量被私有化了</span><br><span class="line">        return num</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">var result = foo()</span><br><span class="line">console.log(result[0]()); // 0</span><br><span class="line">console.log(result[1]()); // 1</span><br><span class="line">console.log(result[2]()); // 2</span><br></pre></td></tr></table></figure>

<p>上面的例子也是挺典型的，一般面试题比较考基础的话就会被问道，上面例子不仅考察到了块作用域的概念，函数作用域的概念，还考察到了闭包的概念（闭包后续讲但不影响这个例子的理解），多琢磨一下就理解了。</p>
<h3 id="第四章：-提升"><a href="#第四章：-提升" class="headerlink" title="第四章： 提升"></a>第四章： 提升</h3><p>提升指的是变量提升和函数提升，为什么JavaScript会有提升这个概念呢，其实也很好理解，因为JavaScript代码是先 <code>编译</code> 后 <code>执行</code> 的，所以在编译阶段就会先对变量和函数做声明，在执行阶段就出现了所谓的变量提升和函数提升了。</p>
<h4 id="1、变量提升"><a href="#1、变量提升" class="headerlink" title="1、变量提升"></a>1、变量提升</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); // undefined</span><br><span class="line">var a = 1;</span><br></pre></td></tr></table></figure>
<p>上面代码 <code>console.log(a); // undefined</code> 就是因为编译阶段先对变量做了声明,先声明了个变量 a, 并默认赋值 undefined</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">console.log(a); // undefined</span><br><span class="line">a = 1;</span><br></pre></td></tr></table></figure>

<h4 id="2、函数提升"><a href="#2、函数提升" class="headerlink" title="2、函数提升"></a>2、函数提升</h4><p>函数同样也存在提升，这就是为什么函数能先调用后声明了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&#x27;---foo----&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:函数表达式不会被提升</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">var foo = function() &#123;</span><br><span class="line">  console.log(&#x27;---foo----&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">// TypeError: foo is not a function</span><br></pre></td></tr></table></figure>

<p>注意：函数会首先被提升，然后才是变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line">foo();</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(&#x27;---foo----&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">// TypeError: foo is not a function</span><br></pre></td></tr></table></figure>

<p>分析一下，因为上面例子编译后是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo = undefined; // 变量名赋值 undefined</span><br><span class="line">function foo() &#123;     // 函数先提升</span><br><span class="line">  console.log(&#x27;---foo----&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">foo = 1;             // 但接下去是变量被重新赋值了 1，是个Number类型</span><br><span class="line">foo();               // Number类型当然不能用函数方式调用，就报错了</span><br><span class="line">// TypeError: foo is not a function</span><br></pre></td></tr></table></figure>

<h3 id="第五章：-作用域闭包"><a href="#第五章：-作用域闭包" class="headerlink" title="第五章： 作用域闭包"></a>第五章： 作用域闭包</h3><p>闭包问题一直会在JavaScript被提起，是JavaScript一个比较奇葩的概念</p>
<h4 id="1、闭包的产生"><a href="#1、闭包的产生" class="headerlink" title="1、闭包的产生"></a>1、闭包的产生</h4><blockquote>
<p>闭包的概念： 当函数可以记住并访问所在的词法作用域时，就产生了闭包</p>
</blockquote>
<p>概念貌似挺简单的，简单分析下，首先闭包是 <code>产生的</code>，是在代码执行中产生的，有的一些网络博文直接将闭包定义为 <code>某一个特殊函数</code> 是错的。</p>
<p>闭包是怎么产生的呢，一个函数能访问到所在函数作用域就产生了闭包，注意到作用域的概念，咱们最上面的章节有提到，看下面例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var a = 0;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    a++;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  return bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bat = foo()</span><br><span class="line">bat() // 1</span><br><span class="line">bat() // 2</span><br><span class="line">bat() // 3</span><br></pre></td></tr></table></figure>

<p>结合例子分析一下： 函数 foo 内部返回了函数 bar ,外部声明个变量 bat 拿到 foo 返回的函数 bar ，执行 bat() 发现能正常输出 1 ，注意前面章节提到的作用域，变量 a 是在函数 foo 内部的一个私有变量，不能被外界访问的，但外部函数 bat 却能访问的到私有变量 a，这说明了 <code>外部函数 bat 持有函数 foo 的作用域</code> ，也就产生了闭包。</p>
<p>闭包的形成有什么用呢，JavaScript 让闭包的存在明显有它的作用，其中一个作用是为了模块化，当然你也可以利用外部函数持有另一个函数作用域的闭包特性去做更多的事情，但这边就暂且讨论模块化这个作用。</p>
<p>函数有什么作用呢，私有化变量或方法呀，那函数内的变量和方法被私有化了函数怎么和外部做 <code>交流</code> 呢, 暴露出一些变量或方法呀</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var _a = 0;</span><br><span class="line">  var b = 0;</span><br><span class="line">  function _add() &#123;</span><br><span class="line">    b = _a + 10    </span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    _add()</span><br><span class="line">  &#125;</span><br><span class="line">  function getB() &#123;</span><br><span class="line">    return b</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    bar: bar,</span><br><span class="line">    getB: getB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bat = foo()</span><br><span class="line">bat.bar()</span><br><span class="line">bat.getB() // 10</span><br></pre></td></tr></table></figure>

<p>上面例子函数 foo 可以理解为一个模块，内部声明了一些私有变量和方法，也对外界暴露了一些方法，只是在执行的过程中顺带产生了一个闭包</p>
<h4 id="2、模块机制"><a href="#2、模块机制" class="headerlink" title="2、模块机制"></a>2、模块机制</h4><p>上面提到了闭包的产生和作用，貌似在使用 <code>es6语法</code> 开发的过程中很少用到了闭包，但实际上我们一直在用闭包的概念的。</p>
<blockquote>
<p> foo.js</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var _a = 0;</span><br><span class="line">var b = 0;</span><br><span class="line">function _add() &#123;</span><br><span class="line">  b = _a + 10</span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">  _add()</span><br><span class="line">&#125;</span><br><span class="line">function getB() &#123;</span><br><span class="line">  return b</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  bar: bar,</span><br><span class="line">  getB: getB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> bat.js</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import bat from &#x27;foo&#x27;</span><br><span class="line"></span><br><span class="line">bat.bar()</span><br><span class="line">bat.getB() // 10</span><br></pre></td></tr></table></figure>

<p>上面例子是 es6 模块的写法，是不是惊奇的发现变量 bat 可以记住并访问模块 foo 的作用域，这符合了闭包的概念。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>本章节我们深入理解了JavaScript的 <code>作用域</code>，<code>提升</code>，<code>闭包</code>等概念，希望你能有所收获，这也是我在读《你不知道的JavaScript·上卷》的一些体会。下一部分整理下 <code>this解析</code>、<code>对象</code>、<code>原型</code> 等一些概念。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iyue.top/2018/08/16/%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E5%85%B3%E8%81%94%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="萌新">
      <meta itemprop="description" content="我是萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山外小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/16/%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E5%85%B3%E8%81%94%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/" class="post-title-link" itemprop="url">将本地代码关联到远程仓库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-16 14:28:57" itemprop="dateCreated datePublished" datetime="2018-08-16T14:28:57+08:00">2018-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 16:17:42" itemprop="dateModified" datetime="2022-01-09T16:17:42+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在项目的建立初期都是先搭建基础框架，在完成基础框架的搭建后，才把代码放到代码管理服务器上，让项目组成员进行检出从而进行需求的开发。而基础框架的搭建大部分都是先在个人的电脑上完成的，当完成框架搭建后，此时就要把代码共享到代码服务器上供开发人员检出。  </p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本地安装git，在远程建有仓库，由于我们是将本地代码推到远程仓库，所以建远程仓库的时候<strong>不要进行初始化</strong>，即不必在仓库下添加任何文件，如readme.mdd等。  </p>
<h2 id="本地仓库初始化"><a href="#本地仓库初始化" class="headerlink" title="本地仓库初始化"></a>本地仓库初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init   // 初始化版本库</span><br><span class="line">git add .   // 添加文件到版本库（只是添加到缓存区），.代表添加文件夹下所有文件 </span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span> // 把添加的文件提交到版本库，并填写提交备注</span><br></pre></td></tr></table></figure>

<h2 id="关联推送"><a href="#关联推送" class="headerlink" title="关联推送"></a>关联推送</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 你的远程库地址  // 把本地库与远程库关联</span><br><span class="line">git push -u origin master    // 第一次推送时</span><br><span class="line">git push origin master  // 第一次推送后，直接使用该命令即可推送修改</span><br></pre></td></tr></table></figure>

<p>之后可能需要输入用户名密码，或者是ssh的形式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iyue.top/2018/08/16/vue%E4%B8%AD%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="萌新">
      <meta itemprop="description" content="我是萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山外小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/16/vue%E4%B8%AD%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">vue中引入图片的方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-16 14:11:14" itemprop="dateCreated datePublished" datetime="2018-08-16T14:11:14+08:00">2018-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 16:17:42" itemprop="dateModified" datetime="2022-01-09T16:17:42+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="template和css中"><a href="#template和css中" class="headerlink" title="template和css中"></a>template和css中</h2><p>在 template 的 img 标签等和 css 的背景图中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;logo-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;~@/assets/logo/logo.png&quot;</span> <span class="attr">key</span>=<span class="string">&quot;max-logo&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">~@/assets/dongdong.png</span>) <span class="number">4px</span> <span class="number">4px</span> no-repeat;</span><br></pre></td></tr></table></figure>

<p>其中‘~’为的是让 webpack 识别这是一个路径，‘@’表示 webpack 中配置的路径别名，此处表示 src 文件夹</p>
<h2 id="在js中"><a href="#在js中" class="headerlink" title="在js中"></a>在js中</h2><p>在 js 中作为变量引入时，需要以 require 的方式引入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">default_avatar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;@/assets/avatar/avatar_&#x27;</span> + <span class="built_in">this</span>.name.length % <span class="number">10</span> + <span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处引入不需要前面写‘~’</p>
<h2 id="assets与static的区别"><a href="#assets与static的区别" class="headerlink" title="assets与static的区别"></a>assets与static的区别</h2><ol>
<li>静态文件（主要指图片）均放在了src文件夹下的assets下，此处考虑到引入的资源都是属于项目本身的文件；此处的文件会被webpack的插件处理，如压缩，base64，hash等；</li>
<li>static中应放置公共的类库等，如jQuery；此处的文件会直接复制到输出文件夹dist下的static中，不会被webpack处理；引入时直接以绝对路径引入即可。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://iyue.top/2018/08/16/node%E5%9C%A8Windows%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="萌新">
      <meta itemprop="description" content="我是萌新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山外小楼">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/08/16/node%E5%9C%A8Windows%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">node在Windows下的安装与配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-16 10:16:35" itemprop="dateCreated datePublished" datetime="2018-08-16T10:16:35+08:00">2018-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-09 16:17:42" itemprop="dateModified" datetime="2022-01-09T16:17:42+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在Windows下安装node很简单，直接取官网下载安装包，一路next就可以了，最新的安装包包含了npm，也会默认把node运行文件所在的目录添加到环境变量中。  </p>
<p>当在终端执行<code>node -v</code>命令时，输出相应版本号说明安装成功。  </p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>npm默认的模块缓存路径及全局安装路径都在C盘，习惯上我们自行指定一个位置，一般会把node安装在D盘，相应的路径也设置在node目录下  </p>
<p>在nodejs的目录下提前创建好两个文件夹node_global和node_cache</p>
<p>如下命令设置路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\\nodejs\\node_global&quot;</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">&quot;D:\\nodejs\\node_cache&quot;</span></span><br></pre></td></tr></table></figure>

<p>设置完成后可通过<code>npm config ls</code>查看相关设置</p>
<p>此时需要将node_global路径加入到环境变量，这样保证终端可以找到全局安装的模块</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>有些教程里会指导将全局模块的路径直接设置在nodejs目录下  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\\nodejs&quot;</span></span><br></pre></td></tr></table></figure>
<p>全局安装的模块会安装在node_modules下，和默认安装的npm在一起，命令文件就在nodejs下，这样就不需要再添加环境变量了  </p>
<p>但这种做法会带来一个问题就是，无法通过<code>npm un npm@lstest -g</code>来升级npm模块，因为npm无法再升级安装的时候覆盖自己，而正常的npm升级是在全局模块的路径安装最新的npm，所以按照开头的路径设置，在node在会有两个npm，一个是默认安装的，一个是升级的时候安装在全局路径的。</p>
<p>所以还是建议全局路径设置另外的文件路径，并添加至环境变量。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">萌新</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
